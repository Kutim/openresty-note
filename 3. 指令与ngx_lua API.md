# Directives

- [lua_capture_error_log](https://github.com/openresty/lua-nginx-module#lua_capture_error_log)
- [lua_use_default_type](https://github.com/openresty/lua-nginx-module#lua_use_default_type)
- [lua_malloc_trim](https://github.com/openresty/lua-nginx-module#lua_malloc_trim)
- [lua_code_cache](https://github.com/openresty/lua-nginx-module#lua_code_cache)
- [lua_regex_cache_max_entries](https://github.com/openresty/lua-nginx-module#lua_regex_cache_max_entries)
- [lua_regex_match_limit](https://github.com/openresty/lua-nginx-module#lua_regex_match_limit)
- [lua_package_path](https://github.com/openresty/lua-nginx-module#lua_package_path)
- [lua_package_cpath](https://github.com/openresty/lua-nginx-module#lua_package_cpath)
- [init_by_lua](https://github.com/openresty/lua-nginx-module#init_by_lua)
- [init_by_lua_block](https://github.com/openresty/lua-nginx-module#init_by_lua_block)
- [init_by_lua_file](https://github.com/openresty/lua-nginx-module#init_by_lua_file)
- [init_worker_by_lua](https://github.com/openresty/lua-nginx-module#init_worker_by_lua)
- [init_worker_by_lua_block](https://github.com/openresty/lua-nginx-module#init_worker_by_lua_block)
- [init_worker_by_lua_file](https://github.com/openresty/lua-nginx-module#init_worker_by_lua_file)
- [set_by_lua](https://github.com/openresty/lua-nginx-module#set_by_lua)
- [set_by_lua_block](https://github.com/openresty/lua-nginx-module#set_by_lua_block)
- [set_by_lua_file](https://github.com/openresty/lua-nginx-module#set_by_lua_file)
- [content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua)
- [content_by_lua_block](https://github.com/openresty/lua-nginx-module#content_by_lua_block)
- [content_by_lua_file](https://github.com/openresty/lua-nginx-module#content_by_lua_file)
- [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua)
- [rewrite_by_lua_block](https://github.com/openresty/lua-nginx-module#rewrite_by_lua_block)
- [rewrite_by_lua_file](https://github.com/openresty/lua-nginx-module#rewrite_by_lua_file)
- [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua)
- [access_by_lua_block](https://github.com/openresty/lua-nginx-module#access_by_lua_block)
- [access_by_lua_file](https://github.com/openresty/lua-nginx-module#access_by_lua_file)
- [header_filter_by_lua](https://github.com/openresty/lua-nginx-module#header_filter_by_lua)
- [header_filter_by_lua_block](https://github.com/openresty/lua-nginx-module#header_filter_by_lua_block)
- [header_filter_by_lua_file](https://github.com/openresty/lua-nginx-module#header_filter_by_lua_file)
- [body_filter_by_lua](https://github.com/openresty/lua-nginx-module#body_filter_by_lua)
- [body_filter_by_lua_block](https://github.com/openresty/lua-nginx-module#body_filter_by_lua_block)
- [body_filter_by_lua_file](https://github.com/openresty/lua-nginx-module#body_filter_by_lua_file)
- [log_by_lua](https://github.com/openresty/lua-nginx-module#log_by_lua)
- [log_by_lua_block](https://github.com/openresty/lua-nginx-module#log_by_lua_block)
- [log_by_lua_file](https://github.com/openresty/lua-nginx-module#log_by_lua_file)
- [balancer_by_lua_block](https://github.com/openresty/lua-nginx-module#balancer_by_lua_block)
- [balancer_by_lua_file](https://github.com/openresty/lua-nginx-module#balancer_by_lua_file)
- [lua_need_request_body](https://github.com/openresty/lua-nginx-module#lua_need_request_body)
- [ssl_certificate_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block)
- [ssl_certificate_by_lua_file](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_file)
- [ssl_session_fetch_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_session_fetch_by_lua_block)
- [ssl_session_fetch_by_lua_file](https://github.com/openresty/lua-nginx-module#ssl_session_fetch_by_lua_file)
- [ssl_session_store_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_block)
- [ssl_session_store_by_lua_file](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_file)
- [lua_shared_dict](https://github.com/openresty/lua-nginx-module#lua_shared_dict)
- [lua_socket_connect_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_connect_timeout)
- [lua_socket_send_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_send_timeout)
- [lua_socket_send_lowat](https://github.com/openresty/lua-nginx-module#lua_socket_send_lowat)
- [lua_socket_read_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout)
- [lua_socket_buffer_size](https://github.com/openresty/lua-nginx-module#lua_socket_buffer_size)
- [lua_socket_pool_size](https://github.com/openresty/lua-nginx-module#lua_socket_pool_size)
- [lua_socket_keepalive_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_keepalive_timeout)
- [lua_socket_log_errors](https://github.com/openresty/lua-nginx-module#lua_socket_log_errors)
- [lua_ssl_ciphers](https://github.com/openresty/lua-nginx-module#lua_ssl_ciphers)
- [lua_ssl_crl](https://github.com/openresty/lua-nginx-module#lua_ssl_crl)
- [lua_ssl_protocols](https://github.com/openresty/lua-nginx-module#lua_ssl_protocols)
- [lua_ssl_trusted_certificate](https://github.com/openresty/lua-nginx-module#lua_ssl_trusted_certificate)
- [lua_ssl_verify_depth](https://github.com/openresty/lua-nginx-module#lua_ssl_verify_depth)
- [lua_http10_buffering](https://github.com/openresty/lua-nginx-module#lua_http10_buffering)
- [rewrite_by_lua_no_postpone](https://github.com/openresty/lua-nginx-module#rewrite_by_lua_no_postpone)
- [access_by_lua_no_postpone](https://github.com/openresty/lua-nginx-module#access_by_lua_no_postpone)
- [lua_transform_underscores_in_response_headers](https://github.com/openresty/lua-nginx-module#lua_transform_underscores_in_response_headers)
- [lua_check_client_abort](https://github.com/openresty/lua-nginx-module#lua_check_client_abort)
- [lua_max_pending_timers](https://github.com/openresty/lua-nginx-module#lua_max_pending_timers)
- [lua_max_running_timers](https://github.com/openresty/lua-nginx-module#lua_max_running_timers)

The basic building blocks of scripting Nginx with Lua are directives. Directives are used to specify when the user Lua code is run andhow the result will be used. Below is a diagram showing the order in which directives are executed.

[![Lua Nginx Modules Directives](https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png)](https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png)

[Back to TOC](https://github.com/openresty/lua-nginx-module#table-of-contents)

## lua_capture_error_log

**syntax:** *lua_capture_error_log size*

**default:** *none*

**context:** *http*

Enables a buffer of the specified `size` for capturing all the nginx error log message data (not just those producedby this module or the nginx http subsystem, but everything) without touching files or disks.

指定大小为 `size` 的缓冲区来捕获nginx 的错误日志数据，而不用接触磁盘文件。

You can use units like `k` and `m` in the `size` value, as in

```
 lua_capture_error_log 100k;
```

As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!

This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.

The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).

You can read the messages in the buffer on the Lua land via the[get_logs()](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs)function of the[ngx.errlog](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme)module of the [lua-resty-core](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme)library. This Lua API function will return the captured error log messages andalso remove these already read from the global capturing buffer, making roomfor any new error log data. For this reason, the user should not configure thisbuffer to be too big if the user read the buffered error log data fast enough.

Note that the log level specified in the standard [error_log](http://nginx.org/r/error_log) directive*does* have effect on this capturing facility. It only captures logmessages of a level no lower than the specified log level in the [error_log](http://nginx.org/r/error_log) directive.The user can still choose to set an even higher filtering log level on the fly via the Lua API function[errlog.set_filter_level](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level).So it is more flexible than the static [error_log](http://nginx.org/r/error_log) directive.

It is worth noting that there is no way to capture the debugging logswithout building OpenResty or NGINX with the `./configure`option `--with-debug`. And enabling debugging logs isstrongly discouraged in production builds due to high overhead.

This directive was first introduced in the `v0.10.9` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_use_default_type

**syntax:** *lua_use_default_type on | off*

**default:** *lua_use_default_type on*

**context:** *http, server, location, location if*

Specifies whether to use the MIME type specified by the [default_type](http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type) directive for the default value of the `Content-Type` response header. Deactivate this directive if a default `Content-Type` response header for Lua request handlers is not desired.

决定是否采用 default_type 指令指定的 MIME 类型。

This directive is turned on by default.

This directive was first introduced in the `v0.9.1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_malloc_trim

**syntax:** *lua_malloc_trim <request-count>*

**default:** *lua_malloc_trim 1000*

**context:** *http*

Asks the underlying `libc` runtime library to release its cached free memory back to the operating system every`N` requests processed by the NGINX core. By default, `N` is 1000. You can configure the request countby using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption andsmaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint.Just tune the number for your own use cases.

让 NGINX core 每处理 N 请求就让 libc  运行库释放缓存的空闲空间。

Configuring the argument to `0` essentially turns off the periodical memory trimming altogether.

```
 lua_malloc_trim 0;  # turn off trimming completely
```

The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the[log_subrequest on](http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest) directives in `nginx.conf`may make the counting faster when subrequests are involved. By default, only "main requests" count.

Note that this directive does *not* affect the memory allocated by LuaJIT's own allocator based on the `mmap`system call.

This directive was first introduced in the `v0.10.7` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_code_cache

**syntax:** *lua_code_cache on | off*

**default:** *lua_code_cache on*

**context:** *http, server, location, location if*

Enables or disables the Lua code cache for Lua code in `*_by_lua_file` directives (like [set_by_lua_file](https://github.com/openresty/lua-nginx-module#set_by_lua_file) and[content_by_lua_file](https://github.com/openresty/lua-nginx-module#content_by_lua_file)) and Lua modules.

启用或禁用 Lua 代码的缓存。（只对 by_file 起作用）

When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the `0.9.3` release. So the Lua files referenced in [set_by_lua_file](https://github.com/openresty/lua-nginx-module#set_by_lua_file),[content_by_lua_file](https://github.com/openresty/lua-nginx-module#content_by_lua_file), [access_by_lua_file](https://github.com/openresty/lua-nginx-module#access_by_lua_file),and etc will not be cachedand all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.

Please note however, that Lua code written inlined within nginx.confsuch as those specified by [set_by_lua](https://github.com/openresty/lua-nginx-module#set_by_lua), [content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua),[access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua), and [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) will not be updated when you edit the inlined Lua code in your `nginx.conf` file because only the Nginx config file parser can correctly parse the `nginx.conf`file and the only way is to reload the config fileby sending a `HUP` signal or just to restart Nginx.

Even when the code cache is enabled, Lua files which are loaded by `dofile` or `loadfile`in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the [init_by_lua](https://github.com/openresty/lua-nginx-module#init_by_lua)or [init_by_lua_file](https://github.com/openresty/lua-nginx-module#init-by_lua_file) directives to load all such files or just make these Lua files true Lua modulesand load them via `require`.

The ngx_lua module does not support the `stat` mode available with theApache `mod_lua` module (yet).

Disabling the Lua code cache is stronglydiscouraged for production use and should only be used duringdevelopment as it has a significant negative impact on overall performance. For example, the performance of a "hello world" Lua example can drop by an order of magnitude after disabling the Lua code cache.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_regex_cache_max_entries

**syntax:** *lua_regex_cache_max_entries <num>*

**default:** *lua_regex_cache_max_entries 1024*

**context:** *http*

Specifies the maximum number of entries allowed in the worker process level compiled regex cache.

指定 worker 级别编译缓存的 regex 最大条数。

The regular expressions used in [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch), [ngx.re.gmatch](https://github.com/openresty/lua-nginx-module#ngxregmatch), [ngx.re.sub](https://github.com/openresty/lua-nginx-module#ngxresub), and [ngx.re.gsub](https://github.com/openresty/lua-nginx-module#ngxregsub) will be cached within this cache if the regex option `o` (i.e., compile-once flag) is specified.

The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the `o` option was not specified) and there will be one, and only one, warning in the `error.log` file:

```
2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...

```

If you are using the `ngx.re.*` implementation of [lua-resty-core](https://github.com/openresty/lua-resty-core) by loading the `resty.core.regex` module (or just the `resty.core` module), then an LRU cache is used for the regex cache being used here.

Do not activate the `o` option for regular expressions (and/or `replace` string arguments for [ngx.re.sub](https://github.com/openresty/lua-nginx-module#ngxresub) and [ngx.re.gsub](https://github.com/openresty/lua-nginx-module#ngxregsub)) that are generated *on the fly* and give rise to infinite variations to avoid hitting the specified limit.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_regex_match_limit

**syntax:** *lua_regex_match_limit <num>*

**default:** *lua_regex_match_limit 0*

**context:** *http*

Specifies the "match limit" used by the PCRE library when executing the [ngx.re API](https://github.com/openresty/lua-nginx-module#ngxrematch). To quote the PCRE manpage, "the limit ... has the effect of limiting the amount of backtracking that can take place."



When the limit is hit, the error string "pcre_exec() failed: -8" will be returned by the [ngx.re API](https://github.com/openresty/lua-nginx-module#ngxrematch) functions on the Lua land.

When setting the limit to 0, the default "match limit" when compiling the PCRE library is used. And this is the default value of this directive.

This directive was first introduced in the `v0.8.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_package_path

**syntax:** *lua_package_path <lua-style-path-str>*

**default:** *The content of LUA_PATH environment variable or Lua's compiled-in defaults.*

**context:** *http*

LUA_PATH 环境变量的内容。


Sets the Lua module search path used by scripts specified by [set_by_lua](https://github.com/openresty/lua-nginx-module#set_by_lua),[content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua) and others. The path string is in standard Lua path form, and `;;`can be used to stand for the original search paths.

As from the `v0.5.0rc29` release, the special notation `$prefix` or `${prefix}` can be used in the search path string to indicate the path of the `server prefix` usually determined by the `-p PATH` command-line option while starting the Nginx server.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_package_cpath

**syntax:** *lua_package_cpath <lua-style-cpath-str>*

**default:** *The content of LUA_CPATH environment variable or Lua's compiled-in defaults.*

**context:** *http*

LUA_CPATH 环境变量的内容

Sets the Lua C-module search path used by scripts specified by [set_by_lua](https://github.com/openresty/lua-nginx-module#set_by_lua),[content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua) and others. The cpath string is in standard Lua cpath form, and `;;`can be used to stand for the original cpath.

As from the `v0.5.0rc29` release, the special notation `$prefix` or `${prefix}` can be used in the search path string to indicate the path of the `server prefix` usually determined by the `-p PATH` command-line option while starting the Nginx server.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## init_by_lua

**syntax:** *init_by_lua <lua-script-str>*

**context:** *http*

**phase:** *loading-config*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [init_by_lua_block](https://github.com/openresty/lua-nginx-module#init_by_lua_block) directive instead.

Runs the Lua code specified by the argument `<lua-script-str>` on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.

在 nginx master 进程加载 nginx 配置文件，在全局的 Lua VM 运行指定的代码。

When Nginx receives the `HUP` signal and starts reloading the config file, the Lua VM will also be re-created and `init_by_lua` will run again on the new Lua VM. In case that the [lua_code_cache](https://github.com/openresty/lua-nginx-module#lua_code_cache) directive is turned off (default on), the `init_by_lua` handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.

Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems' copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:

```
 # this runs before forking out nginx worker processes:
 init_by_lua_block { require "cjson" }

 server {
     location = /api {
         content_by_lua_block {
             -- the following require() will just  return
             -- the alrady loaded module from package.loaded:
             ngx.say(require "cjson".encode{dog = 5, cat = 6})
         }
     }
 }
```

You can also initialize the [lua_shared_dict](https://github.com/openresty/lua-nginx-module#lua_shared_dict) shm storage at this phase. Here is an example for this:

```
 lua_shared_dict dogs 1m;

 init_by_lua_block {
     local dogs = ngx.shared.dogs;
     dogs:set("Tom", 56)
 }

 server {
     location = /api {
         content_by_lua_block {
             local dogs = ngx.shared.dogs;
             ngx.say(dogs:get("Tom"))
         }
     }
 }
```

But note that, the [lua_shared_dict](https://github.com/openresty/lua-nginx-module#lua_shared_dict)'s shm storage will not be cleared through a config reload (via the `HUP` signal, for example). So if you do *not* want to re-initialize the shm storage in your `init_by_lua` code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your `init_by_lua` code.

重新加载配置文件时， lua_shared_dict 的内容不会丢失。

Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the [Copy-on-write (COW)](http://en.wikipedia.org/wiki/Copy-on-write) feature provided by many operating systems among all the worker processes, thus saving a lot of memory.

Do *not* initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the [Lua Variable Scope](https://github.com/openresty/lua-nginx-module#lua-variable-scope) section for more details). The recommended way is to use proper [Lua module](http://www.lua.org/manual/5.1/manual.html#5.3) files (but do not use the standard Lua function [module()](http://www.lua.org/manual/5.1/manual.html#pdf-module) to define Lua modules because it pollutes the global namespace as well) and call [require()](http://www.lua.org/manual/5.1/manual.html#pdf-require) to load your own module files in `init_by_lua` or other contexts ([require()](http://www.lua.org/manual/5.1/manual.html#pdf-require) does cache the loaded Lua modules in the global `package.loaded` table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).

Only a small set of the [Nginx API for Lua](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) is supported in this context:

- Logging APIs: [ngx.log](https://github.com/openresty/lua-nginx-module#ngxlog) and [print](https://github.com/openresty/lua-nginx-module#print),
- Shared Dictionary API: [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

More Nginx APIs for Lua may be supported in this context upon future user requests.

Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.

You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the `root` account.

This directive was first introduced in the `v0.5.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## init_by_lua_block

**syntax:** *init_by_lua_block { lua-script }*

**context:** *http*

**phase:** *loading-config*

Similar to the [init_by_lua](https://github.com/openresty/lua-nginx-module#init_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 init_by_lua_block {
     print("I need no extra escaping here, for example: \r\nblah")
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## init_by_lua_file

**syntax:** *init_by_lua_file <path-to-lua-script-file>*

**context:** *http*

**phase:** *loading-config*

Equivalent to [init_by_lua](https://github.com/openresty/lua-nginx-module#init_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code or [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

相对于启动时使用 `-p` 参数指定的路径

This directive was first introduced in the `v0.5.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## init_worker_by_lua

**syntax:** *init_worker_by_lua <lua-script-str>*

**context:** *http*

**phase:** *starting-worker*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [init_worker_by_lua_block](https://github.com/openresty/lua-nginx-module#init_worker_by_lua_block) directive instead.

Runs the specified Lua code upon every Nginx worker process's startup when the master process is enabled. When the master process is disabled, this hook will just run after [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua).

当启用了 master 进程时，worker 进程启动时会执行指定的 Lua 代码。当 master 进程禁止时，这个会在 init_by_lua* 之后运行。

This hook is often used to create per-worker reoccurring timers (via the [ngx.timer.at](https://github.com/openresty/lua-nginx-module#ngxtimerat) Lua API), either for backend health-check or other timed routine work. Below is an example,

这个钩子常用于创建每个 worker 的定时器，用于后端状态检查，或其他定时任务。

```
 init_worker_by_lua '
     local delay = 3  -- in seconds
     local new_timer = ngx.timer.at
     local log = ngx.log
     local ERR = ngx.ERR
     local check

     check = function(premature)
         if not premature then
             -- do the health check or other routine work
             local ok, err = new_timer(delay, check)
             if not ok then
                 log(ERR, "failed to create timer: ", err)
                 return
             end
         end
     end

     local hdl, err = new_timer(delay, check)
     if not hdl then
         log(ERR, "failed to create timer: ", err)
         return
     end
 ';
```

This directive was first introduced in the `v0.9.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## init_worker_by_lua_block

**syntax:** *init_worker_by_lua_block { lua-script }*

**context:** *http*

**phase:** *starting-worker*

Similar to the [init_worker_by_lua](https://github.com/openresty/lua-nginx-module#init_worker_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 init_worker_by_lua_block {
     print("I need no extra escaping here, for example: \r\nblah")
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## init_worker_by_lua_file

**syntax:** *init_worker_by_lua_file <lua-file-path>*

**context:** *http*

**phase:** *starting-worker*

Similar to [init_worker_by_lua](https://github.com/openresty/lua-nginx-module#init_worker_by_lua), but accepts the file path to a Lua source file or Lua bytecode file.

This directive was first introduced in the `v0.9.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## set_by_lua

**syntax:** *set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]*

**context:** *server, server if, location, location if*

**phase:** *rewrite*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [set_by_lua_block](https://github.com/openresty/lua-nginx-module#set_by_lua_block) directive instead.

Executes code specified in `<lua-script-str>` with optional input arguments `$arg1 $arg2 ...`, and returns string output to `$res`.The code in `<lua-script-str>` can make [API calls](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) and can retrieve input arguments from the `ngx.arg` table (index starts from `1` and increases sequentially).

以 $arg1,$arg2 ... 运行 `<lua-script-str>` 结果返回 $res。`<lua-script-str>` 可以调用 api，获取 ngx.arg 中的参数。

This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.

这个指令用来执行短操作。不应该在此执行耗时的操作。

This directive is implemented by injecting custom commands into the standard [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html)'s command list. Because [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html) does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua "light thread" cannot work in this directive.

这个指令用来将用户指令注入到  ngx_http_rewrite_module 命令列表。由于 ngx_http_rewrite_module 不支持阻塞 I/O   oops。可以 yield 的 Lua API 不能工作在此指令阶段。

At least the following API functions are currently disabled within the context of `set_by_lua`:

- Output API functions (e.g., [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay) and [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers))
- Control API functions (e.g., [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit))
- Subrequest API functions (e.g., [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) and [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi))
- Cosocket API functions (e.g., [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp) and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket)).
- Sleeping API function [ngx.sleep](https://github.com/openresty/lua-nginx-module#ngxsleep).

In addition, note that this directive can only write out a value to a single Nginx variable at a time. However, a workaround is possible using the [ngx.var.VARIABLE](https://github.com/openresty/lua-nginx-module#ngxvarvariable) interface.

可以使用 ngx.var.VARIABLE 来绕过一次只能设置一个 值的限制

```
 location /foo {
     set $diff ''; # we have to predefine the $diff variable here

     set_by_lua $sum '
         local a = 32
         local b = 56

         ngx.var.diff = a - b;  -- write to $diff directly
         return a + b;          -- return the $sum value normally
     ';

     echo "sum = $sum, diff = $diff";
 }
```

This directive can be freely mixed with all directives of the [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html), [set-misc-nginx-module](http://github.com/openresty/set-misc-nginx-module), and [array-var-nginx-module](http://github.com/openresty/array-var-nginx-module) modules. All of these directives will run in the same order as they appear in the config file.

```
 set $foo 32;
 set_by_lua $bar 'return tonumber(ngx.var.foo) + 1';
 set $baz "bar: $bar";  # $baz == "bar: 33"
```

As from the `v0.5.0rc29` release, Nginx variable interpolation is disabled in the `<lua-script-str>` argument of this directive and therefore, the dollar sign character (`$`) can be used directly.

This directive requires the [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) module.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## set_by_lua_block

**syntax:** *set_by_lua_block $res { lua-script }*

**context:** *server, server if, location, location if*

**phase:** *rewrite*

Similar to the [set_by_lua](https://github.com/openresty/lua-nginx-module#set_by_lua) directive except that

1. this directive inlines the Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping), and
2. this directive does not support extra arguments after the Lua script as in [set_by_lua](https://github.com/openresty/lua-nginx-module#set_by_lua).

For example,

```
 set_by_lua_block $res { return 32 + math.cos(32) }
 # $res now has the value "32.834223360507" or alike.
```

No special escaping is required in the Lua code block.

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## set_by_lua_file

**syntax:** *set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 ...]*

**context:** *server, server if, location, location if*

**phase:** *rewrite*

Equivalent to [set_by_lua](https://github.com/openresty/lua-nginx-module#set_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

Nginx variable interpolation is supported in the `<path-to-lua-script-file>` argument string of this directive. But special care must be taken for injection attacks.

支持nginx的变量插入。

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified.The Lua code cache can be temporarily disabled during development byswitching [lua_code_cache](https://github.com/openresty/lua-nginx-module#lua_code_cache) `off` in `nginx.conf` to avoid reloading Nginx.

This directive requires the [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) module.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## content_by_lua

**syntax:** *content_by_lua <lua-script-str>*

**context:** *location, location if*

**phase:** *content*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [content_by_lua_block](https://github.com/openresty/lua-nginx-module#content_by_lua_block) directive instead.

Acts as a "content handler" and executes Lua code string specified in `<lua-script-str>` for every request.The Lua code may make [API calls](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).

作为“内容处理”，对每一个请求执行 Lua 代码。Lua 代码可以调用 API， 以及作为一个独立的全局环境中的新产生的协程执行

Do not use this directive and other content handler directives in the same location. For example, this directive and the [proxy_pass](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass) directive should not be used in the same location.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## content_by_lua_block

**syntax:** *content_by_lua_block { lua-script }*

**context:** *location, location if*

**phase:** *content*

Similar to the [content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 content_by_lua_block {
     ngx.say("I need no extra escaping here, for example: \r\nblah")
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## content_by_lua_file

**syntax:** *content_by_lua_file <path-to-lua-script-file>*

**context:** *location, location if*

**phase:** *content*

Equivalent to [content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

Nginx variables can be used in the `<path-to-lua-script-file>` string to provide flexibility. This however carries some risks and is not ordinarily recommended.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cachedand the Nginx config must be reloaded each time the Lua source file is modified.The Lua code cache can be temporarily disabled during development byswitching [lua_code_cache](https://github.com/openresty/lua-nginx-module#lua_code_cache) `off` in `nginx.conf` to avoid reloading Nginx.

Nginx variables are supported in the file path for dynamic dispatch, for example:

```
 # CAUTION: contents in nginx var must be carefully filtered,
 # otherwise there'll be great security risk!
 location ~ ^/app/([-_a-zA-Z0-9/]+) {
     set $path $1;
     content_by_lua_file /path/to/lua/app/root/$path.lua;
 }
```

But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## rewrite_by_lua

**syntax:** *rewrite_by_lua <lua-script-str>*

**context:** *http, server, location, location if*

**phase:** *rewrite tail*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [rewrite_by_lua_block](https://github.com/openresty/lua-nginx-module#rewrite_by_lua_block) directive instead.

Acts as a rewrite phase handler and executes Lua code string specified in `<lua-script-str>` for every request.The Lua code may make [API calls](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).

作为“重写处理”，对每一个请求执行 Lua 代码。Lua 代码可以调用 API， 以及作为一个独立的全局环境中的新产生的协程执行

Note that this handler always runs *after* the standard [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html). So the following will work as expected:


此阶段的代码会在 ngx_http_rewrite_module 之后执行。

```
 location /foo {
     set $a 12; # create and initialize $a
     set $b ""; # create and initialize $b
     rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
     echo "res = $b";
 }
```

because `set $a 12` and `set $b ""` run *before* [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua).

On the other hand, the following will not work as expected:

```
 ?  location /foo {
 ?      set $a 12; # create and initialize $a
 ?      set $b ''; # create and initialize $b
 ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
 ?      if ($b = '13') {
 ?         rewrite ^ /bar redirect;
 ?         break;
 ?      }
 ?
 ?      echo "res = $b";
 ?  }
```

because `if` runs *before* [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) even if it is placed after [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) in the config.

The right way of doing this is as follows:

```
 location /foo {
     set $a 12; # create and initialize $a
     set $b ''; # create and initialize $b
     rewrite_by_lua '
         ngx.var.b = tonumber(ngx.var.a) + 1
         if tonumber(ngx.var.b) == 13 then
             return ngx.redirect("/bar");
         end
     ';

     echo "res = $b";
 }
```

Note that the [ngx_eval](http://www.grid.net.ru/nginx/eval.en.html) module can be approximated by using [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua). For example,

```
 location / {
     eval $res {
         proxy_pass http://foo.com/check-spam;
     }

     if ($res = 'spam') {
         rewrite ^ /terms-of-use.html redirect;
     }

     fastcgi_pass ...;
 }
```

can be implemented in ngx_lua as:

```
 location = /check-spam {
     internal;
     proxy_pass http://foo.com/check-spam;
 }

 location / {
     rewrite_by_lua '
         local res = ngx.location.capture("/check-spam")
         if res.body == "spam" then
             return ngx.redirect("/terms-of-use.html")
         end
     ';

     fastcgi_pass ...;
 }
```

Just as any other rewrite phase handlers, [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) also runs in subrequests.

Note that when calling `ngx.exit(ngx.OK)` within a [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) handler, calling [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit) with status >= 200 (`ngx.HTTP_OK`) and status < 300 (`ngx.HTTP_SPECIAL_RESPONSE`) for successful quits and `ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)` (or its friends) for failures.

If the [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html)'s [rewrite](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite) directive is used to change the URI and initiate location re-lookups (internal redirections), then any [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) or [rewrite_by_lua_file](https://github.com/openresty/lua-nginx-module#rewrite_by_lua_file) code sequences within the current location will not be executed. For example,

如果使用 ngx_http_rewrite_module 的 rewrite ，那之后的 rewrite_by_lua 不会执行。

```
 location /foo {
     rewrite ^ /bar;
     rewrite_by_lua 'ngx.exit(503)';
 }
 location /bar {
     ...
 }
```

Here the Lua code `ngx.exit(503)` will never run. This will be the case if `rewrite ^ /bar last` is used as this will similarly initiate an internal redirection. If the `break` modifier is used instead, there will be no internal redirection and the `rewrite_by_lua` code will be executed.

The `rewrite_by_lua` code will always run at the end of the `rewrite` request-processing phase unless [rewrite_by_lua_no_postpone](https://github.com/openresty/lua-nginx-module#rewrite_by_lua_no_postpone) is turned on.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## rewrite_by_lua_block

**syntax:** *rewrite_by_lua_block { lua-script }*

**context:** *http, server, location, location if*

**phase:** *rewrite tail*

Similar to the [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 rewrite_by_lua_block {
     do_something("hello, world!\nhiya\n")
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## rewrite_by_lua_file

**syntax:** *rewrite_by_lua_file <path-to-lua-script-file>*

**context:** *http, server, location, location if*

**phase:** *rewrite tail*

Equivalent to [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

Nginx variables can be used in the `<path-to-lua-script-file>` string to provide flexibility. This however carries some risks and is not ordinarily recommended.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching [lua_code_cache](https://github.com/openresty/lua-nginx-module#lua_code_cache) `off` in `nginx.conf` to avoid reloading Nginx.

The `rewrite_by_lua_file` code will always run at the end of the `rewrite` request-processing phase unless [rewrite_by_lua_no_postpone](https://github.com/openresty/lua-nginx-module#rewrite_by_lua_no_postpone) is turned on.

Nginx variables are supported in the file path for dynamic dispatch just as in [content_by_lua_file](https://github.com/openresty/lua-nginx-module#content_by_lua_file).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## access_by_lua

**syntax:** *access_by_lua <lua-script-str>*

**context:** *http, server, location, location if*

**phase:** *access tail*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [access_by_lua_block](https://github.com/openresty/lua-nginx-module#access_by_lua_block) directive instead.

Acts as an access phase handler and executes Lua code string specified in `<lua-script-str>` for every request.The Lua code may make [API calls](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).

Note that this handler always runs *after* the standard [ngx_http_access_module](http://nginx.org/en/docs/http/ngx_http_access_module.html). So the following will work as expected:

此阶段的代码会在 ngx_http_access_module 之后执行。

```
 location / {
     deny    192.168.1.1;
     allow   192.168.1.0/24;
     allow   10.1.1.0/16;
     deny    all;

     access_by_lua '
         local res = ngx.location.capture("/mysql", { ... })
         ...
     ';

     # proxy_pass/fastcgi_pass/...
 }
```

That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua).

Note that the [ngx_auth_request](http://mdounin.ru/hg/ngx_http_auth_request_module/) module can be approximated by using [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua):

```
 location / {
     auth_request /auth;

     # proxy_pass/fastcgi_pass/postgres_pass/...
 }
```

can be implemented in ngx_lua as:

```
 location / {
     access_by_lua '
         local res = ngx.location.capture("/auth")

         if res.status == ngx.HTTP_OK then
             return
         end

         if res.status == ngx.HTTP_FORBIDDEN then
             ngx.exit(res.status)
         end

         ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
     ';

     # proxy_pass/fastcgi_pass/postgres_pass/...
 }
```

As with other access phase handlers, [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua) will *not* run in subrequests.

Note that when calling `ngx.exit(ngx.OK)` within a [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua) handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua) handler, calling [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit) with status >= 200 (`ngx.HTTP_OK`) and status < 300 (`ngx.HTTP_SPECIAL_RESPONSE`) for successful quits and `ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)` (or its friends) for failures.

Starting from the `v0.9.20` release, you can use the [access_by_lua_no_postpone](https://github.com/openresty/lua-nginx-module#access_by_lua_no_postpone)directive to control when to run this handler inside the "access" request-processing phaseof NGINX.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## access_by_lua_block

**syntax:** *access_by_lua_block { lua-script }*

**context:** *http, server, location, location if*

**phase:** *access tail*

Similar to the [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 access_by_lua_block {
     do_something("hello, world!\nhiya\n")
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## access_by_lua_file

**syntax:** *access_by_lua_file <path-to-lua-script-file>*

**context:** *http, server, location, location if*

**phase:** *access tail*

Equivalent to [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

Nginx variables can be used in the `<path-to-lua-script-file>` string to provide flexibility. This however carries some risks and is not ordinarily recommended.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cachedand the Nginx config must be reloaded each time the Lua source file is modified.The Lua code cache can be temporarily disabled during development by switching [lua_code_cache](https://github.com/openresty/lua-nginx-module#lua_code_cache) `off` in `nginx.conf` to avoid repeatedly reloading Nginx.

Nginx variables are supported in the file path for dynamic dispatch just as in [content_by_lua_file](https://github.com/openresty/lua-nginx-module#content_by_lua_file).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## header_filter_by_lua

**syntax:** *header_filter_by_lua <lua-script-str>*

**context:** *http, server, location, location if*

**phase:** *output-header-filter*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [header_filter_by_lua_block](https://github.com/openresty/lua-nginx-module#header_filter_by_lua_block) directive instead.

Uses Lua code specified in `<lua-script-str>` to define an output header filter.

Note that the following API functions are currently disabled within this context:

在此阶段不允许下面的 API 函数

- Output API functions (e.g., [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay) and [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers))
- Control API functions (e.g., [ngx.redirect](https://github.com/openresty/lua-nginx-module#ngxredirect) and [ngx.exec](https://github.com/openresty/lua-nginx-module#ngxexec))
- Subrequest API functions (e.g., [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) and [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi))
- Cosocket API functions (e.g., [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp) and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket)).

Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:

```
 location / {
     proxy_pass http://mybackend;
     header_filter_by_lua 'ngx.header.Foo = "blah"';
 }
```

This directive was first introduced in the `v0.2.1rc20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## header_filter_by_lua_block

**syntax:** *header_filter_by_lua_block { lua-script }*

**context:** *http, server, location, location if*

**phase:** *output-header-filter*

Similar to the [header_filter_by_lua](https://github.com/openresty/lua-nginx-module#header_filter_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 header_filter_by_lua_block {
     ngx.header["content-length"] = nil
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## header_filter_by_lua_file

**syntax:** *header_filter_by_lua_file <path-to-lua-script-file>*

**context:** *http, server, location, location if*

**phase:** *output-header-filter*

Equivalent to [header_filter_by_lua](https://github.com/openresty/lua-nginx-module#header_filter_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

This directive was first introduced in the `v0.2.1rc20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## body_filter_by_lua

**syntax:** *body_filter_by_lua <lua-script-str>*

**context:** *http, server, location, location if*

**phase:** *output-body-filter*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [body_filter_by_lua_block](https://github.com/openresty/lua-nginx-module#body_filter_by_lua_block) directive instead.

Uses Lua code specified in `<lua-script-str>` to define an output body filter.

The input data chunk is passed via [ngx.arg](https://github.com/openresty/lua-nginx-module#ngxarg)[1] (as a Lua string value) and the "eof" flag indicating the end of the response body data stream is passed via [ngx.arg](https://github.com/openresty/lua-nginx-module#ngxarg)[2] (as a Lua boolean value).

输入的数据通过 ngx.arg[1] 传递，ngx.arg[2] 为 “eof” 标志，只是是否结尾。

Behind the scene, the "eof" flag is just the `last_buf` (for main requests) or `last_in_chain` (for subrequests) flag of the Nginx chain link buffers. (Before the `v0.7.14` release, the "eof" flag does not work at all in subrequests.)

The output data stream can be aborted immediately by running the following Lua statement:

```
 return ngx.ERROR
```

This will truncate the response body and usually result in incomplete and also invalid responses.

The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding [ngx.arg](https://github.com/openresty/lua-nginx-module#ngxarg)[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:

```
 location / {
     proxy_pass http://mybackend;
     body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';
 }
```

When setting `nil` or an empty Lua string value to `ngx.arg[1]`, no data chunk will be passed to the downstream Nginx output filters at all.

Likewise, new "eof" flag can also be specified by setting a boolean value to [ngx.arg](https://github.com/openresty/lua-nginx-module#ngxarg)[2]. For example,

下面检测到指定内容后，设置结束。然后丢弃其他内容。
```
 location /t {
     echo hello world;
     echo hiya globe;

     body_filter_by_lua '
         local chunk = ngx.arg[1]
         if string.match(chunk, "hello") then
             ngx.arg[2] = true  -- new eof
             return
         end

         -- just throw away any remaining chunk data
         ngx.arg[1] = nil
     ';
 }
```

Then `GET /t` will just return the output

```
hello world

```

That is, when the body filter sees a chunk containing the word "hello", then it will set the "eof" flag to true immediately, resulting in truncated but still valid responses.

When the Lua code may change the length of the response body, then it is required to always clear out the `Content-Length` response header (if any) in a header filter to enforce streaming output, as in

当 Lua 可能改变响应体的长度事，经常需要清除 响应体的   `Content-Length`。如果不清除此字段，客户端一直在等待。

```
 location /foo {
     # fastcgi_pass/proxy_pass/...

     header_filter_by_lua_block { ngx.header.content_length = nil }
     body_filter_by_lua 'ngx.arg[1] = string.len(ngx.arg[1]) .. "\\n"';
 }
```

Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter's current implementation:

- Output API functions (e.g., [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay) and [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers))
- Control API functions (e.g., [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit) and [ngx.exec](https://github.com/openresty/lua-nginx-module#ngxexec))
- Subrequest API functions (e.g., [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) and [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi))
- Cosocket API functions (e.g., [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp) and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket)).

Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.

此阶段的代码可能会运行多次（如果结果，分块传输）

This directive was first introduced in the `v0.5.0rc32` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## body_filter_by_lua_block

**syntax:** *body_filter_by_lua_block { lua-script-str }*

**context:** *http, server, location, location if*

**phase:** *output-body-filter*

Similar to the [body_filter_by_lua](https://github.com/openresty/lua-nginx-module#body_filter_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 body_filter_by_lua_block {
     local data, eof = ngx.arg[1], ngx.arg[2]
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## body_filter_by_lua_file

**syntax:** *body_filter_by_lua_file <path-to-lua-script-file>*

**context:** *http, server, location, location if*

**phase:** *output-body-filter*

Equivalent to [body_filter_by_lua](https://github.com/openresty/lua-nginx-module#body_filter_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

This directive was first introduced in the `v0.5.0rc32` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## log_by_lua

**syntax:** *log_by_lua <lua-script-str>*

**context:** *http, server, location, location if*

**phase:** *log*

**NOTE** Use of this directive is *discouraged* following the `v0.9.17` release. Use the [log_by_lua_block](https://github.com/openresty/lua-nginx-module#log_by_lua_block) directive instead.

Runs the Lua source code inlined as the `<lua-script-str>` at the `log` request processing phase. This does not replace the current access logs, but runs before.

此阶段在 access logs 之前运行。

Note that the following API functions are currently disabled within this context:

- Output API functions (e.g., [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay) and [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers))
- Control API functions (e.g., [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit))
- Subrequest API functions (e.g., [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) and [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi))
- Cosocket API functions (e.g., [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp) and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket)).

Here is an example of gathering average data for [$upstream_response_time](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time):

```
 lua_shared_dict log_dict 5M;

 server {
     location / {
         proxy_pass http://mybackend;

         log_by_lua '
             local log_dict = ngx.shared.log_dict
             local upstream_time = tonumber(ngx.var.upstream_response_time)

             local sum = log_dict:get("upstream_time-sum") or 0
             sum = sum + upstream_time
             log_dict:set("upstream_time-sum", sum)

             local newval, err = log_dict:incr("upstream_time-nb", 1)
             if not newval and err == "not found" then
                 log_dict:add("upstream_time-nb", 0)
                 log_dict:incr("upstream_time-nb", 1)
             end
         ';
     }

     location = /status {
         content_by_lua_block {
             local log_dict = ngx.shared.log_dict
             local sum = log_dict:get("upstream_time-sum")
             local nb = log_dict:get("upstream_time-nb")

             if nb and sum then
                 ngx.say("average upstream response time: ", sum / nb,
                         " (", nb, " reqs)")
             else
                 ngx.say("no data yet")
             end
         }
     }
 }
```

This directive was first introduced in the `v0.5.0rc31` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## log_by_lua_block

**syntax:** *log_by_lua_block { lua-script }*

**context:** *http, server, location, location if*

**phase:** *log*

Similar to the [log_by_lua](https://github.com/openresty/lua-nginx-module#log_by_lua) directive except that this directive inlinesthe Lua source directlyinside a pair of curly braces (`{}`) instead of in an NGINX string literal (which requiresspecial character escaping).

For instance,

```
 log_by_lua_block {
     print("I need no extra escaping here, for example: \r\nblah")
 }
```

This directive was first introduced in the `v0.9.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## log_by_lua_file

**syntax:** *log_by_lua_file <path-to-lua-script-file>*

**context:** *http, server, location, location if*

**phase:** *log*

Equivalent to [log_by_lua](https://github.com/openresty/lua-nginx-module#log_by_lua), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

This directive was first introduced in the `v0.5.0rc31` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## balancer_by_lua_block

**syntax:** *balancer_by_lua_block { lua-script }*

**context:** *upstream*

**phase:** *content*

This directive runs Lua code as an upstream balancer for any upstream entities definedby the `upstream {}` configuration block.

该指令运行Lua代码，作为由上游配置块定义的任何上游实体的上游均衡器。

For instance,

```
 upstream foo {
     server 127.0.0.1;
     balancer_by_lua_block {
         -- use Lua to do something interesting here
         -- as a dynamic balancer
     }
 }

 server {
     location / {
         proxy_pass http://foo;
     }
 }
```

The resulting Lua load balancer can work with any existing nginx upstream moduleslike [ngx_proxy](http://nginx.org/en/docs/http/ngx_http_proxy_module.html) and[ngx_fastcgi](http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html).

Also, the Lua load balancer can work with the standard upstream connection pool mechanism,i.e., the standard [keepalive](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive) directive.Just ensure that the [keepalive](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive) directiveis used *after* this `balancer_by_lua_block` directive in a single `upstream {}` configuration block.

也可以使用连接池机制，标准的 keepalive 指令。在单个  upstream 配置块中，确保 keepalive 指令在 balancer_by_lua_block 之后。

The Lua load balancer can totally ignore the list of servers defined in the `upstream {}` blockand select peer from a completely dynamic server list (even changing per request) via the[ngx.balancer](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md) modulefrom the [lua-resty-core](https://github.com/openresty/lua-resty-core) library.

负载均衡会忽略 upstream 中定义的 server，通过 ngx_balancer 模块动态获取 server 列表。

The Lua code handler registered by this directive might get called more than once in a singledownstream request when the nginx upstream mechanism retries the request on conditionsspecified by directives like the [proxy_next_upstream](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream)directive.

This Lua code execution context does not support yielding, so Lua APIs that may yield(like cosockets and "light threads") are disabled in this context. One can usually workaround this limitation by doing such operations in an earlier phase handler (like[access_by_lua*](https://github.com/openresty/lua-nginx-module#access_by_lua)) and passing along the result into this contextvia the [ngx.ctx](https://github.com/openresty/lua-nginx-module#ngxctx) table.

此阶段不支持阻塞，可以通过之前的阶段进行绕过（出入  ngx.ctx）。

This directive was first introduced in the `v0.10.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## balancer_by_lua_file

**syntax:** *balancer_by_lua_file <path-to-lua-script-file>*

**context:** *upstream*

**phase:** *content*

Equivalent to [balancer_by_lua_block](https://github.com/openresty/lua-nginx-module#balancer_by_lua_block), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

This directive was first introduced in the `v0.10.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_need_request_body

**syntax:** *lua_need_request_body <on|off>*

**default:** *off*

**context:** *http, server, location, location if*

**phase:** *depends on usage*

Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned `on` or the [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body) function should be called within the Lua code.

决定是否在 rewrite/access/access_by_lua* 之前强制读取请求体。

To read the request body data within the [$request_body](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body) variable,[client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size) must have the same value as [client_max_body_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size). Because when the content length exceeds [client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size) but less than [client_max_body_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size), Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the [$request_body](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body) variable.

如果超过请求体限制的大小，会写入磁盘，这样 $request_body 的值会为空。

If the current location includes [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) directives,then the request body will be read just before the [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) code is run (and also at the`rewrite` phase). Similarly, if only [content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua) is specified,the request body will not be read until the content handler's Lua code isabout to run (i.e., the request body will be read during the content phase).

如果有 rewrite_by_lua* 指令，会在 rewrite_by_lua* 之前读取请求体。如果只有 content_by_lua ，在其 Lua 代码运行之前才会读取请求体（即 content 阶段）

It is recommended however, to use the [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body) and [ngx.req.discard_body](https://github.com/openresty/lua-nginx-module#ngxreqdiscard_body) functions for finer control over the request body reading process instead.

This also applies to [access_by_lua*](https://github.com/openresty/lua-nginx-module#access_by_lua).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## ssl_certificate_by_lua_block

**syntax:** *ssl_certificate_by_lua_block { lua-script }*

**context:** *server*

**phase:** *right-before-SSL-handshake*

This directive runs user Lua code when NGINX is about to start the SSL handshake for the downstreamSSL (https) connections.

此阶段用于与下游建立 ssl 握手。

It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-requestbasis. It is also useful to load such handshake configurations nonblockingly from the remote (for example,with the [cosocket](https://github.com/openresty/lua-nginx-module#ngxsockettcp) API). And one can also do per-request OCSP stapling handling in pureLua here as well.

可通过 api 获取 配置

Another typical use case is to do SSL handshake traffic control nonblockingly in this context,with the help of the [lua-resty-limit-traffic#readme](https://github.com/openresty/lua-resty-limit-traffic)library, for example.

One can also do interesting things with the SSL handshake requests from the client side, likerejecting old SSL clients using the SSLv3 protocol or even below selectively.

也可用于流量控制。

The [ngx.ssl](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md)and [ngx.ocsp](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md) Lua modulesprovided by the [lua-resty-core](https://github.com/openresty/lua-resty-core/#readme)library are particularly useful in this context. You can use the Lua API offered by these two Lua modulesto manipulate the SSL certificate chain and private key for the current SSL connectionbeing initiated.

This Lua handler does not run at all, however, when NGINX/OpenSSL successfully resumesthe SSL session via SSL session IDs or TLS session tickets for the current SSL connection. Inother words, this Lua handler only runs when NGINX has to initiate a full SSL handshake.

此阶段对于复用的 ssl 不起作用。

Below is a trivial example using the[ngx.ssl](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md) moduleat the same time:

```
 server {
     listen 443 ssl;
     server_name   test.com;

     ssl_certificate_by_lua_block {
         print("About to initiate a new SSL handshake!")
     }

     location / {
         root html;
     }
 }
```

See more complicated examples in the [ngx.ssl](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md)and [ngx.ocsp](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md)Lua modules' official documentation.

Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the[ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit) call with an error code like `ngx.ERROR`.

This Lua code execution context *does* support yielding, so Lua APIs that may yield(like cosockets, sleeping, and "light threads")are enabled in this context.
此阶段可以阻塞。

Note, however, you still need to configure the [ssl_certificate](http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate) and[ssl_certificate_key](http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key)directives even though you will not use this static certificate and private key at all. This isbecause the NGINX core requires their appearance otherwise you are seeing the following errorwhile starting NGINX:

尽管不使用静态的 证书，还是需要使用 ssl_certificate and ssl_certificate_key 指令（nginx 需要此指令）。

```
nginx: [emerg] no ssl configured for the server

```

This directive currently requires the following NGINX core patch to work correctly:

<http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html>

The bundled version of the NGINX core in OpenResty 1.9.7.2 (or above) already has thispatch applied.

Furthermore, one needs at least OpenSSL 1.0.2e for this directive to work.

This directive was first introduced in the `v0.10.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## ssl_certificate_by_lua_file

**syntax:** *ssl_certificate_by_lua_file <path-to-lua-script-file>*

**context:** *server*

**phase:** *right-before-SSL-handshake*

Equivalent to [ssl_certificate_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or, as from the `v0.5.0rc32` release, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

This directive was first introduced in the `v0.10.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## ssl_session_fetch_by_lua_block

**syntax:** *ssl_session_fetch_by_lua_block { lua-script }*

**context:** *http*

**phase:** *right-before-SSL-handshake*

This directive runs Lua code to look up and load the SSL session (if any) according to the session IDprovided by the current SSL handshake request for the downstream.

此阶段通过 Lua 获得 SSL seesion。

The Lua API for obtaining the current session ID and loading a cached SSL session datais provided in the [ngx.ssl.session](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md)Lua module shipped with the [lua-resty-core](https://github.com/openresty/lua-resty-core#readme)library.

此阶段可以阻塞。

Lua APIs that may yield, like [ngx.sleep](https://github.com/openresty/lua-nginx-module#ngxsleep) and [cosockets](https://github.com/openresty/lua-nginx-module#ngxsockettcp),are enabled in this context.

This hook, together with the [ssl_session_store_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_block) hook,can be used to implement distributed caching mechanisms in pure Lua (basedon the [cosocket](https://github.com/openresty/lua-nginx-module#ngxsockettcp) API, for example). If a cached SSL session is foundand loaded into the current SSL connection context,SSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.

Please note that TLS session tickets are very different and it is the clients' responsibilityto cache the SSL session state when session tickets are used. SSL session resumptions based onTLS session tickets would happen automatically without going through this hook (nor the[ssl_session_store_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua) hook). This hook is mainlyfor older or less capable SSL clients that can only do SSL sessions by session IDs.

When [ssl_certificate_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block) is specified at the same time,this hook usually runs before [ssl_certificate_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block).When the SSL session is found and successfully loaded for the current SSL connection,SSL session resumption will happen and thus bypass the [ssl_certificate_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block)hook completely. In this case, NGINX also bypasses the [ssl_session_store_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua)hook, for obvious reasons.

To easily test this hook locally with a modern web browser, you can temporarily put the following linein your https server block to disable the TLS session ticket support:

```
ssl_session_tickets off;

```

But do not forget to comment this line out before publishing your site to the world.

If you are using the [official pre-built packages](http://openresty.org/en/linux-packages.html) for [OpenResty](https://openresty.org/)1.11.2.1 or later, then everything should work out of the box.

If you are using OpenSSL libraries not provided by [OpenResty](https://openresty.org),then you need to apply the following patch for OpenSSL 1.0.2h or later:

<https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch>

If you are not using the NGINX core shipped with [OpenResty](https://openresty.org) 1.11.2.1 or later, then you need toapply the following patch to the standard NGINX core 1.11.2 or later:

<http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch>

This directive was first introduced in the `v0.10.6` release.

Note that: this directive is only allowed to used in **http context** from the `v0.10.7` release(because SSL session resumption happens before server name dispatch).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## ssl_session_fetch_by_lua_file

**syntax:** *ssl_session_fetch_by_lua_file <path-to-lua-script-file>*

**context:** *http*

**phase:** *right-before-SSL-handshake*

Equivalent to [ssl_session_fetch_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_session_fetch_by_lua_block), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or rather, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

This directive was first introduced in the `v0.10.6` release.

Note that: this directive is only allowed to used in **http context** from the `v0.10.7` release(because SSL session resumption happens before server name dispatch).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## ssl_session_store_by_lua_block

**syntax:** *ssl_session_store_by_lua_block { lua-script }*

**context:** *http*

**phase:** *right-after-SSL-handshake*

This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream. The saved or cached SSLsession data can be used for future SSL connections to resume SSL sessions without goingthrough the full SSL handshake process (which is very expensive in terms of CPU time).

此阶段用于存储、获取 SSL session。

Lua APIs that may yield, like [ngx.sleep](https://github.com/openresty/lua-nginx-module#ngxsleep) and [cosockets](https://github.com/openresty/lua-nginx-module#ngxsockettcp),are *disabled* in this context. You can still, however, use the [ngx.timer.at](https://github.com/openresty/lua-nginx-module#ngxtimerat) APIto create 0-delay timers to save the SSL session data asynchronously to external services (like `redis` or `memcached`).

The Lua API for obtaining the current session ID and the associated session state datais provided in the [ngx.ssl.session](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme)Lua module shipped with the [lua-resty-core](https://github.com/openresty/lua-resty-core#readme)library.

To easily test this hook locally with a modern web browser, you can temporarily put the following linein your https server block to disable the TLS session ticket support:

```
ssl_session_tickets off;

```

But do not forget to comment this line out before publishing your site to the world.

This directive was first introduced in the `v0.10.6` release.

Note that: this directive is only allowed to used in **http context** from the `v0.10.7` release(because SSL session resumption happens before server name dispatch).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## ssl_session_store_by_lua_file

**syntax:** *ssl_session_store_by_lua_file <path-to-lua-script-file>*

**context:** *http*

**phase:** *right-before-SSL-handshake*

Equivalent to [ssl_session_store_by_lua_block](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_block), except that the file specified by `<path-to-lua-script-file>` contains the Lua code, or rather, the [Lua/LuaJIT bytecode](https://github.com/openresty/lua-nginx-module#lualuajit-bytecode-support) to be executed.

When a relative path like `foo/bar.lua` is given, they will be turned into the absolute path relative to the `server prefix` path determined by the `-p PATH` command-line option while starting the Nginx server.

This directive was first introduced in the `v0.10.6` release.

Note that: this directive is only allowed to used in **http context** from the `v0.10.7` release(because SSL session resumption happens before server name dispatch).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_shared_dict

**syntax:** *lua_shared_dict <name> <size>*

**default:** *no*

**context:** *http*

**phase:** *depends on usage*

Declares a shared memory zone, `<name>`, to serve as storage for the shm based Lua dictionary `ngx.shared.<name>`.

声明一个共享内存区域。

Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.

The `<size>` argument accepts size units such as `k` and `m`:

```
 http {
     lua_shared_dict dogs 10m;
     ...
 }
```

The hard-coded minimum size is 8KB while the practical minimum size dependson actual user data set (some people start with 12KB).

See [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict) for details.

This directive was first introduced in the `v0.3.1rc22` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_connect_timeout

**syntax:** *lua_socket_connect_timeout <time>*

**default:** *lua_socket_connect_timeout 60s*

**context:** *http, server, location*

This directive controls the default timeout value used in TCP/unix-domain socket object's [connect](https://github.com/openresty/lua-nginx-module#tcpsockconnect) method and can be overridden by the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) or [settimeouts](https://github.com/openresty/lua-nginx-module#tcpsocksettimeouts) methods.

此用于 TCP 对象连接的超时时间。可以被覆盖

The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.

This directive was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_send_timeout

**syntax:** *lua_socket_send_timeout <time>*

**default:** *lua_socket_send_timeout 60s*

**context:** *http, server, location*

Controls the default timeout value used in TCP/unix-domain socket object's [send](https://github.com/openresty/lua-nginx-module#tcpsocksend) method and can be overridden by the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) or [settimeouts](https://github.com/openresty/lua-nginx-module#tcpsocksettimeouts) methods.

此用于 TCP 对象发送的超时时间。可以被覆盖

The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.

This directive was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_send_lowat

**syntax:** *lua_socket_send_lowat <size>*

**default:** *lua_socket_send_lowat 0*

**context:** *http, server, location*

Controls the `lowat` (low water) value for the cosocket send buffer.

此用于控制 发送缓冲的大小。可以被覆盖

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_read_timeout

**syntax:** *lua_socket_read_timeout <time>*

**default:** *lua_socket_read_timeout 60s*

**context:** *http, server, location*

**phase:** *depends on usage*

This directive controls the default timeout value used in TCP/unix-domain socket object's [receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive) method and iterator functions returned by the [receiveuntil](https://github.com/openresty/lua-nginx-module#tcpsockreceiveuntil) method. This setting can be overridden by the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) or [settimeouts](https://github.com/openresty/lua-nginx-module#tcpsocksettimeouts) methods.

用于控制 接收的超时时间，可以被覆盖

The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.

This directive was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_buffer_size

**syntax:** *lua_socket_buffer_size <size>*

**default:** *lua_socket_buffer_size 4k/8k*

**context:** *http, server, location*

Specifies the buffer size used by cosocket reading operations.

指定 读取时 缓冲大小。

This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even `1` byte buffer size should still work everywhere but the performance could be terrible.

This directive was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_pool_size

**syntax:** *lua_socket_pool_size <size>*

**default:** *lua_socket_pool_size 30*

**context:** *http, server, location*

Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).

指定 cosocket 连接池的大小（对于每一个远端server）

Default to 30 connections for every pool.

When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.

Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.

此处的值是对每一个 worker的

This directive was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_keepalive_timeout

**syntax:** *lua_socket_keepalive_timeout <time>*

**default:** *lua_socket_keepalive_timeout 60s*

**context:** *http, server, location*

This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' [setkeepalive](https://github.com/openresty/lua-nginx-module#tcpsocksetkeepalive) method.

用于控制空闲的超时时间，可被覆盖。

The `<time>` argument can be an integer, with an optional time unit, like `s` (second), `ms` (millisecond), `m` (minute). The default time unit is `s`, i.e., "second". The default setting is `60s`.

This directive was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_socket_log_errors

**syntax:** *lua_socket_log_errors on|off*

**default:** *lua_socket_log_errors on*

**context:** *http, server, location*

This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).

用于 TCP 、UDP 出错时的错误日志。如果通过Lua 代码已经处理过，建议关闭，以免写入 nginx 的错误日志。

This directive was first introduced in the `v0.5.13` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_ssl_ciphers

**syntax:** *lua_ssl_ciphers <ciphers>*

**default:** *lua_ssl_ciphers DEFAULT*

**context:** *http, server, location*

Specifies the enabled ciphers for requests to a SSL/TLS server in the [tcpsock:sslhandshake](https://github.com/openresty/lua-nginx-module#tcpsocksslhandshake) method. The ciphers are specified in the format understood by the OpenSSL library.

指定用于 tcpsock:sslhandshake  的ssl算法

The full list can be viewed using the “openssl ciphers” command.

This directive was first introduced in the `v0.9.11` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_ssl_crl

**syntax:** *lua_ssl_crl <file>*

**default:** *no*

**context:** *http, server, location*

Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the [tcpsock:sslhandshake](https://github.com/openresty/lua-nginx-module#tcpsocksslhandshake) method.

指定用于 tcpsock:sslhandshake 验证证书的 CRL 文件（pem格式）

This directive was first introduced in the `v0.9.11` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_ssl_protocols

**syntax:** *lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]*

**default:** *lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2*

**context:** *http, server, location*

Enables the specified protocols for requests to a SSL/TLS server in the [tcpsock:sslhandshake](https://github.com/openresty/lua-nginx-module#tcpsocksslhandshake) method.

指定 启用的 SSL 协议。

This directive was first introduced in the `v0.9.11` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_ssl_trusted_certificate

**syntax:** *lua_ssl_trusted_certificate <file>*

**default:** *no*

**context:** *http, server, location*

Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the [tcpsock:sslhandshake](https://github.com/openresty/lua-nginx-module#tcpsocksslhandshake) method.

指定用于 tcpsock:sslhandshake 验证的 根证书

This directive was first introduced in the `v0.9.11` release.

See also [lua_ssl_verify_depth](https://github.com/openresty/lua-nginx-module#lua_ssl_verify_depth).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_ssl_verify_depth

**syntax:** *lua_ssl_verify_depth <number>*

**default:** *lua_ssl_verify_depth 1*

**context:** *http, server, location*

Sets the verification depth in the server certificates chain.

服务器证书链的验证深度

This directive was first introduced in the `v0.9.11` release.

See also [lua_ssl_trusted_certificate](https://github.com/openresty/lua-nginx-module#lua_ssl_trusted_certificate).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_http10_buffering

**syntax:** *lua_http10_buffering on|off*

**default:** *lua_http10_buffering on*

**context:** *http, server, location, location-if*

Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper `Content-Length` response header.

启用或禁用 Http 1.0 请求的自动响应缓存。

If the Lua code explicitly sets a `Content-Length` response header before sending the headers (either explicitly via [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers) or implicitly via the first [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay) or [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint) call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.

To output very large response data in a streaming fashion (via the [ngx.flush](https://github.com/openresty/lua-nginx-module#ngxflush) call, for example), this directive MUST be turned off to minimize memory usage.

This directive is turned `on` by default.

This directive was first introduced in the `v0.5.0rc19` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## rewrite_by_lua_no_postpone

**syntax:** *rewrite_by_lua_no_postpone on|off*

**default:** *rewrite_by_lua_no_postpone off*

**context:** *http*

Controls whether or not to disable postponing [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) directives to run at the end of the `rewrite` request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the `rewrite` phase.

将  rewrite_by_lua*  指令放在 rewrite 最后。

This directive was first introduced in the `v0.5.0rc29` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## access_by_lua_no_postpone

**syntax:** *access_by_lua_no_postpone on|off*

**default:** *access_by_lua_no_postpone off*

**context:** *http*

Controls whether or not to disable postponing [access_by_lua*](https://github.com/openresty/lua-nginx-module#access_by_lua) directives to run at the end of the `access` request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the `access` phase.

将 access_by_lua* 指令放在 access 最后

This directive was first introduced in the `v0.9.20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_transform_underscores_in_response_headers

**syntax:** *lua_transform_underscores_in_response_headers on|off*

**default:** *lua_transform_underscores_in_response_headers on*

**context:** *http, server, location, location-if*

Controls whether to transform underscores (`_`) in the response header names specified in the [ngx.header.HEADER](https://github.com/openresty/lua-nginx-module#ngxheaderheader) API to hypens (`-`).

控制将 响应头中的下划线转为 -

This directive was first introduced in the `v0.5.0rc32` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_check_client_abort

**syntax:** *lua_check_client_abort on|off*

**default:** *lua_check_client_abort off*

**context:** *http, server, location, location-if*

This directive controls whether to check for premature client connection abortion.

此指令用于检测 客户端是否过早终止。

When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by [ngx.on_abort](https://github.com/openresty/lua-nginx-module#ngxon_abort)) or just stop and clean up all the Lua "light threads" running in the current request's request handler when there is no user callback function registered.

According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket), then ngx_lua will neither stop all the running "light threads" nor call the user callback (if [ngx.on_abort](https://github.com/openresty/lua-nginx-module#ngxon_abort) has been called). Instead, the reading operation on [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket) will just return the error message "client aborted" as the second return value (the first return value is surely `nil`).

When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a `FIN` packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the [TCP keepalive](http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html) support in your system's TCP stack implementation in order to detect "half-open" TCP connections in time.

For example, on Linux, you can configure the standard [listen](http://nginx.org/en/docs/http/ngx_http_core_module.html#listen) directive in your `nginx.conf` file like this:

```
 listen 80 so_keepalive=2s:2s:8;
```

On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:

```
# sysctl net.inet.tcp.keepintvl=2000
# sysctl net.inet.tcp.keepidle=2000

```

This directive was first introduced in the `v0.7.4` release.

See also [ngx.on_abort](https://github.com/openresty/lua-nginx-module#ngxon_abort).

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_max_pending_timers

**syntax:** *lua_max_pending_timers <count>*

**default:** *lua_max_pending_timers 1024*

**context:** *http*

Controls the maximum number of pending timers allowed.

Pending timers are those timers that have not expired yet.

When exceeding this limit, the [ngx.timer.at](https://github.com/openresty/lua-nginx-module#ngxtimerat) call will immediately return `nil` and the error string "too many pending timers".

This directive was first introduced in the `v0.8.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

## lua_max_running_timers

**syntax:** *lua_max_running_timers <count>*

**default:** *lua_max_running_timers 256*

**context:** *http*

Controls the maximum number of "running timers" allowed.

Running timers are those timers whose user callback functions are still running.

When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message "N lua_max_running_timers are not enough" where "N" is the current value of this directive.

This directive was first introduced in the `v0.8.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#directives)

# Nginx API for Lua

- [Introduction](https://github.com/openresty/lua-nginx-module#introduction)
- [ngx.arg](https://github.com/openresty/lua-nginx-module#ngxarg)
- [ngx.var.VARIABLE](https://github.com/openresty/lua-nginx-module#ngxvarvariable)
- [Core constants](https://github.com/openresty/lua-nginx-module#core-constants)
- [HTTP method constants](https://github.com/openresty/lua-nginx-module#http-method-constants)
- [HTTP status constants](https://github.com/openresty/lua-nginx-module#http-status-constants)
- [Nginx log level constants](https://github.com/openresty/lua-nginx-module#nginx-log-level-constants)
- [print](https://github.com/openresty/lua-nginx-module#print)
- [ngx.ctx](https://github.com/openresty/lua-nginx-module#ngxctx)
- [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture)
- [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi)
- [ngx.status](https://github.com/openresty/lua-nginx-module#ngxstatus)
- [ngx.header.HEADER](https://github.com/openresty/lua-nginx-module#ngxheaderheader)
- [ngx.resp.get_headers](https://github.com/openresty/lua-nginx-module#ngxrespget_headers)
- [ngx.req.is_internal](https://github.com/openresty/lua-nginx-module#ngxreqis_internal)
- [ngx.req.start_time](https://github.com/openresty/lua-nginx-module#ngxreqstart_time)
- [ngx.req.http_version](https://github.com/openresty/lua-nginx-module#ngxreqhttp_version)
- [ngx.req.raw_header](https://github.com/openresty/lua-nginx-module#ngxreqraw_header)
- [ngx.req.get_method](https://github.com/openresty/lua-nginx-module#ngxreqget_method)
- [ngx.req.set_method](https://github.com/openresty/lua-nginx-module#ngxreqset_method)
- [ngx.req.set_uri](https://github.com/openresty/lua-nginx-module#ngxreqset_uri)
- [ngx.req.set_uri_args](https://github.com/openresty/lua-nginx-module#ngxreqset_uri_args)
- [ngx.req.get_uri_args](https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args)
- [ngx.req.get_post_args](https://github.com/openresty/lua-nginx-module#ngxreqget_post_args)
- [ngx.req.get_headers](https://github.com/openresty/lua-nginx-module#ngxreqget_headers)
- [ngx.req.set_header](https://github.com/openresty/lua-nginx-module#ngxreqset_header)
- [ngx.req.clear_header](https://github.com/openresty/lua-nginx-module#ngxreqclear_header)
- [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body)
- [ngx.req.discard_body](https://github.com/openresty/lua-nginx-module#ngxreqdiscard_body)
- [ngx.req.get_body_data](https://github.com/openresty/lua-nginx-module#ngxreqget_body_data)
- [ngx.req.get_body_file](https://github.com/openresty/lua-nginx-module#ngxreqget_body_file)
- [ngx.req.set_body_data](https://github.com/openresty/lua-nginx-module#ngxreqset_body_data)
- [ngx.req.set_body_file](https://github.com/openresty/lua-nginx-module#ngxreqset_body_file)
- [ngx.req.init_body](https://github.com/openresty/lua-nginx-module#ngxreqinit_body)
- [ngx.req.append_body](https://github.com/openresty/lua-nginx-module#ngxreqappend_body)
- [ngx.req.finish_body](https://github.com/openresty/lua-nginx-module#ngxreqfinish_body)
- [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket)
- [ngx.exec](https://github.com/openresty/lua-nginx-module#ngxexec)
- [ngx.redirect](https://github.com/openresty/lua-nginx-module#ngxredirect)
- [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers)
- [ngx.headers_sent](https://github.com/openresty/lua-nginx-module#ngxheaders_sent)
- [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint)
- [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay)
- [ngx.log](https://github.com/openresty/lua-nginx-module#ngxlog)
- [ngx.flush](https://github.com/openresty/lua-nginx-module#ngxflush)
- [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit)
- [ngx.eof](https://github.com/openresty/lua-nginx-module#ngxeof)
- [ngx.sleep](https://github.com/openresty/lua-nginx-module#ngxsleep)
- [ngx.escape_uri](https://github.com/openresty/lua-nginx-module#ngxescape_uri)
- [ngx.unescape_uri](https://github.com/openresty/lua-nginx-module#ngxunescape_uri)
- [ngx.encode_args](https://github.com/openresty/lua-nginx-module#ngxencode_args)
- [ngx.decode_args](https://github.com/openresty/lua-nginx-module#ngxdecode_args)
- [ngx.encode_base64](https://github.com/openresty/lua-nginx-module#ngxencode_base64)
- [ngx.decode_base64](https://github.com/openresty/lua-nginx-module#ngxdecode_base64)
- [ngx.crc32_short](https://github.com/openresty/lua-nginx-module#ngxcrc32_short)
- [ngx.crc32_long](https://github.com/openresty/lua-nginx-module#ngxcrc32_long)
- [ngx.hmac_sha1](https://github.com/openresty/lua-nginx-module#ngxhmac_sha1)
- [ngx.md5](https://github.com/openresty/lua-nginx-module#ngxmd5)
- [ngx.md5_bin](https://github.com/openresty/lua-nginx-module#ngxmd5_bin)
- [ngx.sha1_bin](https://github.com/openresty/lua-nginx-module#ngxsha1_bin)
- [ngx.quote_sql_str](https://github.com/openresty/lua-nginx-module#ngxquote_sql_str)
- [ngx.today](https://github.com/openresty/lua-nginx-module#ngxtoday)
- [ngx.time](https://github.com/openresty/lua-nginx-module#ngxtime)
- [ngx.now](https://github.com/openresty/lua-nginx-module#ngxnow)
- [ngx.update_time](https://github.com/openresty/lua-nginx-module#ngxupdate_time)
- [ngx.localtime](https://github.com/openresty/lua-nginx-module#ngxlocaltime)
- [ngx.utctime](https://github.com/openresty/lua-nginx-module#ngxutctime)
- [ngx.cookie_time](https://github.com/openresty/lua-nginx-module#ngxcookie_time)
- [ngx.http_time](https://github.com/openresty/lua-nginx-module#ngxhttp_time)
- [ngx.parse_http_time](https://github.com/openresty/lua-nginx-module#ngxparse_http_time)
- [ngx.is_subrequest](https://github.com/openresty/lua-nginx-module#ngxis_subrequest)
- [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch)
- [ngx.re.find](https://github.com/openresty/lua-nginx-module#ngxrefind)
- [ngx.re.gmatch](https://github.com/openresty/lua-nginx-module#ngxregmatch)
- [ngx.re.sub](https://github.com/openresty/lua-nginx-module#ngxresub)
- [ngx.re.gsub](https://github.com/openresty/lua-nginx-module#ngxregsub)
- [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict)
- [ngx.shared.DICT.get](https://github.com/openresty/lua-nginx-module#ngxshareddictget)
- [ngx.shared.DICT.get_stale](https://github.com/openresty/lua-nginx-module#ngxshareddictget_stale)
- [ngx.shared.DICT.set](https://github.com/openresty/lua-nginx-module#ngxshareddictset)
- [ngx.shared.DICT.safe_set](https://github.com/openresty/lua-nginx-module#ngxshareddictsafe_set)
- [ngx.shared.DICT.add](https://github.com/openresty/lua-nginx-module#ngxshareddictadd)
- [ngx.shared.DICT.safe_add](https://github.com/openresty/lua-nginx-module#ngxshareddictsafe_add)
- [ngx.shared.DICT.replace](https://github.com/openresty/lua-nginx-module#ngxshareddictreplace)
- [ngx.shared.DICT.delete](https://github.com/openresty/lua-nginx-module#ngxshareddictdelete)
- [ngx.shared.DICT.incr](https://github.com/openresty/lua-nginx-module#ngxshareddictincr)
- [ngx.shared.DICT.lpush](https://github.com/openresty/lua-nginx-module#ngxshareddictlpush)
- [ngx.shared.DICT.rpush](https://github.com/openresty/lua-nginx-module#ngxshareddictrpush)
- [ngx.shared.DICT.lpop](https://github.com/openresty/lua-nginx-module#ngxshareddictlpop)
- [ngx.shared.DICT.rpop](https://github.com/openresty/lua-nginx-module#ngxshareddictrpop)
- [ngx.shared.DICT.llen](https://github.com/openresty/lua-nginx-module#ngxshareddictllen)
- [ngx.shared.DICT.flush_all](https://github.com/openresty/lua-nginx-module#ngxshareddictflush_all)
- [ngx.shared.DICT.flush_expired](https://github.com/openresty/lua-nginx-module#ngxshareddictflush_expired)
- [ngx.shared.DICT.get_keys](https://github.com/openresty/lua-nginx-module#ngxshareddictget_keys)
- [ngx.socket.udp](https://github.com/openresty/lua-nginx-module#ngxsocketudp)
- [udpsock:setpeername](https://github.com/openresty/lua-nginx-module#udpsocksetpeername)
- [udpsock:send](https://github.com/openresty/lua-nginx-module#udpsocksend)
- [udpsock:receive](https://github.com/openresty/lua-nginx-module#udpsockreceive)
- [udpsock:close](https://github.com/openresty/lua-nginx-module#udpsockclose)
- [udpsock:settimeout](https://github.com/openresty/lua-nginx-module#udpsocksettimeout)
- [ngx.socket.stream](https://github.com/openresty/lua-nginx-module#ngxsocketstream)
- [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp)
- [tcpsock:connect](https://github.com/openresty/lua-nginx-module#tcpsockconnect)
- [tcpsock:sslhandshake](https://github.com/openresty/lua-nginx-module#tcpsocksslhandshake)
- [tcpsock:send](https://github.com/openresty/lua-nginx-module#tcpsocksend)
- [tcpsock:receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive)
- [tcpsock:receiveuntil](https://github.com/openresty/lua-nginx-module#tcpsockreceiveuntil)
- [tcpsock:close](https://github.com/openresty/lua-nginx-module#tcpsockclose)
- [tcpsock:settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout)
- [tcpsock:settimeouts](https://github.com/openresty/lua-nginx-module#tcpsocksettimeouts)
- [tcpsock:setoption](https://github.com/openresty/lua-nginx-module#tcpsocksetoption)
- [tcpsock:setkeepalive](https://github.com/openresty/lua-nginx-module#tcpsocksetkeepalive)
- [tcpsock:getreusedtimes](https://github.com/openresty/lua-nginx-module#tcpsockgetreusedtimes)
- [ngx.socket.connect](https://github.com/openresty/lua-nginx-module#ngxsocketconnect)
- [ngx.get_phase](https://github.com/openresty/lua-nginx-module#ngxget_phase)
- [ngx.thread.spawn](https://github.com/openresty/lua-nginx-module#ngxthreadspawn)
- [ngx.thread.wait](https://github.com/openresty/lua-nginx-module#ngxthreadwait)
- [ngx.thread.kill](https://github.com/openresty/lua-nginx-module#ngxthreadkill)
- [ngx.on_abort](https://github.com/openresty/lua-nginx-module#ngxon_abort)
- [ngx.timer.at](https://github.com/openresty/lua-nginx-module#ngxtimerat)
- [ngx.timer.every](https://github.com/openresty/lua-nginx-module#ngxtimerevery)
- [ngx.timer.running_count](https://github.com/openresty/lua-nginx-module#ngxtimerrunning_count)
- [ngx.timer.pending_count](https://github.com/openresty/lua-nginx-module#ngxtimerpending_count)
- [ngx.config.subsystem](https://github.com/openresty/lua-nginx-module#ngxconfigsubsystem)
- [ngx.config.debug](https://github.com/openresty/lua-nginx-module#ngxconfigdebug)
- [ngx.config.prefix](https://github.com/openresty/lua-nginx-module#ngxconfigprefix)
- [ngx.config.nginx_version](https://github.com/openresty/lua-nginx-module#ngxconfignginx_version)
- [ngx.config.nginx_configure](https://github.com/openresty/lua-nginx-module#ngxconfignginx_configure)
- [ngx.config.ngx_lua_version](https://github.com/openresty/lua-nginx-module#ngxconfigngx_lua_version)
- [ngx.worker.exiting](https://github.com/openresty/lua-nginx-module#ngxworkerexiting)
- [ngx.worker.pid](https://github.com/openresty/lua-nginx-module#ngxworkerpid)
- [ngx.worker.count](https://github.com/openresty/lua-nginx-module#ngxworkercount)
- [ngx.worker.id](https://github.com/openresty/lua-nginx-module#ngxworkerid)
- [ngx.semaphore](https://github.com/openresty/lua-nginx-module#ngxsemaphore)
- [ngx.balancer](https://github.com/openresty/lua-nginx-module#ngxbalancer)
- [ngx.ssl](https://github.com/openresty/lua-nginx-module#ngxssl)
- [ngx.ocsp](https://github.com/openresty/lua-nginx-module#ngxocsp)
- [ndk.set_var.DIRECTIVE](https://github.com/openresty/lua-nginx-module#ndkset_vardirective)
- [coroutine.create](https://github.com/openresty/lua-nginx-module#coroutinecreate)
- [coroutine.resume](https://github.com/openresty/lua-nginx-module#coroutineresume)
- [coroutine.yield](https://github.com/openresty/lua-nginx-module#coroutineyield)
- [coroutine.wrap](https://github.com/openresty/lua-nginx-module#coroutinewrap)
- [coroutine.running](https://github.com/openresty/lua-nginx-module#coroutinerunning)
- [coroutine.status](https://github.com/openresty/lua-nginx-module#coroutinestatus)

[Back to TOC](https://github.com/openresty/lua-nginx-module#table-of-contents)

## Introduction

The various `*_by_lua`, `*_by_lua_block` and `*_by_lua_file` configuration directives serve as gateways to the Lua API within the `nginx.conf` file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.

The API is exposed to Lua in the form of two standard packages `ngx` and `ndk`. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.

The packages can be introduced into external Lua modules like this:

```
 local say = ngx.say

 local _M = {}

 function _M.foo(a)
     say(a)
 end

 return _M
```

Use of the [package.seeall](http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall) flag is strongly discouraged due to its various bad side-effects.

It is also possible to directly require the packages in external Lua modules:

```
 local ngx = require "ngx"
 local ndk = require "ndk"
```

The ability to require these packages was introduced in the `v0.2.1rc19` release.

Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua `io` library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx's subrequests (via the [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) method and similar) is strongly recommended for maximum performance.

网络的 I/O 操作应尽可能使用 nginx lua api。小量的磁盘操作可以通过 Lua 的io 来实现.推荐使用 nginx 的 subrequests 来实现 网络和 磁盘 I/O。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.arg

**syntax:** *val = ngx.arg[index]*

**context:** *set_by_lua\*, body_filter_by_lua**

When this is used in the context of the [set_by_lua*](https://github.com/openresty/lua-nginx-module#set_by_lua) directives, this table is read-only and holds the input arguments to the config directives:

用于 set_by_lua* 时，只读的 table ，存储配置输入的参数。

```
 value = ngx.arg[n]
```

Here is an example

```
 location /foo {
     set $a 32;
     set $b 56;

     set_by_lua $sum
         'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'
         $a $b;

     echo $sum;
 }
```

that writes out `88`, the sum of `32` and `56`.

When this table is used in the context of [body_filter_by_lua*](https://github.com/openresty/lua-nginx-module#body_filter_by_lua), the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the "eof" flag indicating the end of the whole output data stream.

用于 body_filter_by_lua* ，第一个元素存储输入 outfilter 的数据块，第二个元素为 boolean 值，指示是否到数据块的结尾。

The data chunk and "eof" flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting `nil` or an empty Lua string value to `ngx.arg[1]`, no data chunk will be passed to the downstream Nginx output filters at all.

传递给 outfilter 的数据块、 “eof” 标志可以通过赋值哎改变元素的

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.var.VARIABLE

**syntax:** *ngx.var.VAR_NAME*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Read and write Nginx variable values.

读写 nginx 的变量值。

```
 value = ngx.var.some_nginx_variable_name
 ngx.var.some_nginx_variable_name = value
```

Note that only already defined nginx variables can be written to.For example:

只可以写已经定义的变量。

```
 location /foo {
     set $my_var ''; # this line is required to create $my_var at config time
     content_by_lua_block {
         ngx.var.my_var = 123;
         ...
     }
 }
```

That is, nginx variables cannot be created on-the-fly.

Some special nginx variables like `$args` and `$limit_rate` can be assigned a value,many others are not, like `$query_string`, `$arg_PARAMETER`, and `$http_NAME`.

Nginx regex group capturing variables `$1`, `$2`, `$3`, and etc, can be read by thisinterface as well, by writing `ngx.var[1]`, `ngx.var[2]`, `ngx.var[3]`, and etc.

Setting `ngx.var.Foo` to a `nil` value will unset the `$Foo` Nginx variable.

```
 ngx.var.args = nil
```

**CAUTION** When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,

```
 local val = ngx.var.some_var
 --- use the val repeatedly later
```

to prevent (temporary) memory leaking within the current request's lifetime. Another way of caching the result is to use the [ngx.ctx](https://github.com/openresty/lua-nginx-module#ngxctx) table.

Undefined NGINX variables are evaluated to `nil` while uninitialized (but defined) NGINX variables are evaluated to an empty Lua string.

This API requires a relatively expensive metamethod call and it is recommended to avoid using it on hot code paths.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## Core constants

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

```
   ngx.OK (0)
   ngx.ERROR (-1)
   ngx.AGAIN (-2)
   ngx.DONE (-4)
   ngx.DECLINED (-5)
```

Note that only three of these constants are utilized by the [Nginx API for Lua](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) (i.e., [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit) accepts `NGX_OK`, `NGX_ERROR`, and `NGX_DECLINED` as input).

```
   ngx.null
```

The `ngx.null` constant is a `NULL` light userdata usually used to represent nil values in Lua tables etc and is similar to the [lua-cjson](http://www.kyne.com.au/%7Emark/software/lua-cjson.php) library's `cjson.null` constant. This constant was first introduced in the `v0.5.0rc5` release.

The `ngx.DECLINED` constant was first introduced in the `v0.5.0rc19` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## HTTP method constants

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

```
  ngx.HTTP_GET
  ngx.HTTP_HEAD
  ngx.HTTP_PUT
  ngx.HTTP_POST
  ngx.HTTP_DELETE
  ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)
  ngx.HTTP_MKCOL     (added in the v0.8.2 release)
  ngx.HTTP_COPY      (added in the v0.8.2 release)
  ngx.HTTP_MOVE      (added in the v0.8.2 release)
  ngx.HTTP_PROPFIND  (added in the v0.8.2 release)
  ngx.HTTP_PROPPATCH (added in the v0.8.2 release)
  ngx.HTTP_LOCK      (added in the v0.8.2 release)
  ngx.HTTP_UNLOCK    (added in the v0.8.2 release)
  ngx.HTTP_PATCH     (added in the v0.8.2 release)
  ngx.HTTP_TRACE     (added in the v0.8.2 release)

```

These constants are usually used in [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) and [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi) method calls.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## HTTP status constants

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

```
   value = ngx.HTTP_CONTINUE (100) (first added in the v0.9.20 release)
   value = ngx.HTTP_SWITCHING_PROTOCOLS (101) (first added in the v0.9.20 release)
   value = ngx.HTTP_OK (200)
   value = ngx.HTTP_CREATED (201)
   value = ngx.HTTP_ACCEPTED (202) (first added in the v0.9.20 release)
   value = ngx.HTTP_NO_CONTENT (204) (first added in the v0.9.20 release)
   value = ngx.HTTP_PARTIAL_CONTENT (206) (first added in the v0.9.20 release)
   value = ngx.HTTP_SPECIAL_RESPONSE (300)
   value = ngx.HTTP_MOVED_PERMANENTLY (301)
   value = ngx.HTTP_MOVED_TEMPORARILY (302)
   value = ngx.HTTP_SEE_OTHER (303)
   value = ngx.HTTP_NOT_MODIFIED (304)
   value = ngx.HTTP_TEMPORARY_REDIRECT (307) (first added in the v0.9.20 release)
   value = ngx.HTTP_BAD_REQUEST (400)
   value = ngx.HTTP_UNAUTHORIZED (401)
   value = ngx.HTTP_PAYMENT_REQUIRED (402) (first added in the v0.9.20 release)
   value = ngx.HTTP_FORBIDDEN (403)
   value = ngx.HTTP_NOT_FOUND (404)
   value = ngx.HTTP_NOT_ALLOWED (405)
   value = ngx.HTTP_NOT_ACCEPTABLE (406) (first added in the v0.9.20 release)
   value = ngx.HTTP_REQUEST_TIMEOUT (408) (first added in the v0.9.20 release)
   value = ngx.HTTP_CONFLICT (409) (first added in the v0.9.20 release)
   value = ngx.HTTP_GONE (410)
   value = ngx.HTTP_UPGRADE_REQUIRED (426) (first added in the v0.9.20 release)
   value = ngx.HTTP_TOO_MANY_REQUESTS (429) (first added in the v0.9.20 release)
   value = ngx.HTTP_CLOSE (444) (first added in the v0.9.20 release)
   value = ngx.HTTP_ILLEGAL (451) (first added in the v0.9.20 release)
   value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
   value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)
   value = ngx.HTTP_BAD_GATEWAY (502) (first added in the v0.9.20 release)
   value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
   value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)
   value = ngx.HTTP_VERSION_NOT_SUPPORTED (505) (first added in the v0.9.20 release)
   value = ngx.HTTP_INSUFFICIENT_STORAGE (507) (first added in the v0.9.20 release)
```

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## Nginx log level constants

**context:** *init_by_lua\*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

```
   ngx.STDERR
   ngx.EMERG
   ngx.ALERT
   ngx.CRIT
   ngx.ERR
   ngx.WARN
   ngx.NOTICE
   ngx.INFO
   ngx.DEBUG
```

These constants are usually used by the [ngx.log](https://github.com/openresty/lua-nginx-module#ngxlog) method.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## print

**syntax:** *print(...)*

**context:** *init_by_lua\*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Writes argument values into the nginx `error.log` file with the `ngx.NOTICE` log level.

print 相当于 notice 级别的错误日志

It is equivalent to

```
 ngx.log(ngx.NOTICE, ...)
```

Lua `nil` arguments are accepted and result in literal `"nil"` strings while Lua booleans result in literal `"true"` or `"false"` strings. And the `ngx.null` constant will yield the `"null"` string output.

There is a hard coded `2048` byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the `NGX_MAX_ERROR_STR` macro definition in the `src/core/ngx_log.h` file in the Nginx source tree.

此处最新的版本 1.13  是 4k 限制。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.ctx

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua**

This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).

这个 table 用来存储每一个请求的上下文数据。与请求的生命周期相同。

Consider the following example,

```
 location /test {
     rewrite_by_lua_block {
         ngx.ctx.foo = 76
     }
     access_by_lua_block {
         ngx.ctx.foo = ngx.ctx.foo + 3
     }
     content_by_lua_block {
         ngx.say(ngx.ctx.foo)
     }
 }
```

Then `GET /test` will yield the output

```
 79
```

That is, the `ngx.ctx.foo` entry persists across the rewrite, access, and content phases of a request.

Every request, including subrequests, has its own copy of the table. For example:

每一个请求，包括子请求，都拥有自己的 table。

```
 location /sub {
     content_by_lua_block {
         ngx.say("sub pre: ", ngx.ctx.blah)
         ngx.ctx.blah = 32
         ngx.say("sub post: ", ngx.ctx.blah)
     }
 }

 location /main {
     content_by_lua_block {
         ngx.ctx.blah = 73
         ngx.say("main pre: ", ngx.ctx.blah)
         local res = ngx.location.capture("/sub")
         ngx.print(res.body)
         ngx.say("main post: ", ngx.ctx.blah)
     }
 }
```

Then `GET /main` will give the output

```
 main pre: 73
 sub pre: nil
 sub post: 32
 main post: 73
```

Here, modification of the `ngx.ctx.blah` entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of `ngx.ctx.blah`.

Internal redirection will destroy the original request `ngx.ctx` data (if any) and the new request will have an empty `ngx.ctx` table. For instance,

内部重定向会破坏原始请求的 ngx.ctx。

```
 location /new {
     content_by_lua_block {
         ngx.say(ngx.ctx.foo)
     }
 }

 location /orig {
     content_by_lua_block {
         ngx.ctx.foo = "hello"
         ngx.exec("/new")
     }
 }
```

Then `GET /orig` will give

```
 nil
```

rather than the original `"hello"` value.

Arbitrary data values, including Lua closures and nested tables, can be inserted into this "magic" table. It also allows the registration of custom meta methods.

Overriding `ngx.ctx` with a new Lua table is also supported, for example,

任何数据类型（包括 Lua 闭包，嵌套的table）都可以插入 ctx。

```
 ngx.ctx = { foo = 32, bar = 54 }
```

When being used in the context of [init_worker_by_lua*](https://github.com/openresty/lua-nginx-module#init_worker_by_lua), this table just has the same lifetime of the current Lua handler.

当使用在  init_worker_by_lua* 中， ctx 的生命周期与 当前的 Lua 处理相同。

The `ngx.ctx` lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per-request data along by your own function arguments. So do not abuse this API for saving your own function arguments because it usually has quite some performance impact.

使用 ngx.ctx 来传递参数会有较大的性能损耗。

Because of the metamethod magic, never "local" the `ngx.ctx` table outside your Lua function scope on the Lua module level due to [worker-level data sharing](https://github.com/openresty/lua-nginx-module#data-sharing-within-an-nginx-worker). For example, the following is bad:

```
 -- mymodule.lua
 local _M = {}

 -- the following line is bad since ngx.ctx is a per-request
 -- data while this <code>ctx</code> variable is on the Lua module level
 -- and thus is per-nginx-worker.
 local ctx = ngx.ctx

 function _M.main()
     ctx.foo = "bar"
 end

 return _M
```

Use the following instead:

```
 -- mymodule.lua
 local _M = {}

 function _M.main(ctx)
     ctx.foo = "bar"
 end

 return _M
```

That is, let the caller pass the `ctx` table explicitly via a function argument.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.location.capture

**syntax:** *res = ngx.location.capture(uri, options?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Issues a synchronous but still non-blocking *Nginx Subrequest* using `uri`.

使用uri发出一个同步但仍然不阻塞的Nginx子请求。

Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or *any* other nginx C modules like `ngx_proxy`, `ngx_fastcgi`, `ngx_memc`,`ngx_postgres`, `ngx_drizzle`, and even ngx_lua itself and etc etc etc.

nginx 子请求提供了强大的非阻塞内部请求到其他目录文件、nginx C 模块，甚至是 ngx_lua 自身。

Also note that subrequests just mimic the HTTP interface but there is *no* extra HTTP/TCP traffic *nor* IPC involved. Everything works internally, efficiently, on the C level.

注意，子请求是模拟 http 接口，没有实际的 HTTP/TCP 或 IPC 调用。所有工作是内部、有效、c 级别的。

Subrequests are completely different from HTTP 301/302 redirection (via [ngx.redirect](https://github.com/openresty/lua-nginx-module#ngxredirect)) and internal redirection (via [ngx.exec](https://github.com/openresty/lua-nginx-module#ngxexec)).

子请求与 http 的 301/302 和 内部重定向（ngx.exec）完全不同。

You should always read the request body (by either calling [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body) or configuring [lua_need_request_body](https://github.com/openresty/lua-nginx-module#lua_need_request_body) on) before initiating a subrequest.

在初始化子请求前，需要读取请求体。

This API function (as well as [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi)) always buffers the whole response body of the subrequest in memory. Thus, you should use [cosockets](https://github.com/openresty/lua-nginx-module#ngxsockettcp)and streaming processing instead if you have to handle large subrequest responses.

这个 api 会在内存中缓存子请求的响应体。在处理大的子请求响应时，应该使用 cosockets 和 流处理。

Here is a basic example:

```
 res = ngx.location.capture(uri)
```

Returns a Lua table with 4 slots: `res.status`, `res.header`, `res.body`, and `res.truncated`.

返回的 Lua table 包含四个部分：状态、头、体、是否截断。

`res.status` holds the response status code for the subrequest response.

`res.header` holds all the response headers of thesubrequest and it is a normal Lua table. For multi-value response headers,the value is a Lua (array) table that holds all the values in the order thatthey appear. For instance, if the subrequest response headers contain the followinglines:

```
 Set-Cookie: a=3
 Set-Cookie: foo=bar
 Set-Cookie: baz=blah
```

Then `res.header["Set-Cookie"]` will be evaluated to the table value`{"a=3", "foo=bar", "baz=blah"}`.

`res.body` holds the subrequest's response body data, which might be truncated. You always need to check the `res.truncated` boolean flag to see if `res.body` contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.

响应体因不可恢复的错误而发生截断：例如，远端在传输响应体信息时过早的终止链接，或者在读取响应体时发生超时。

URI query strings can be concatenated to URI itself, for instance,

```
 res = ngx.location.capture('/foo/bar?a=3&b=4')
```

Named locations like `@foo` are not allowed due to a limitation inthe nginx core. Use normal locations combined with the `internal` directive to prepare internal-only locations.

由于 nginx 内核的限制，不支持命名的 location。使用 internal 指令来实现内部的 location

An optional option table can be fed as the secondargument, which supports the options:

- `method`specify the subrequest's request method, which only accepts constants like `ngx.HTTP_POST`.
- `body`specify the subrequest's request body (string value only).
- `args`specify the subrequest's URI query arguments (both string value and Lua tables are accepted)
- `ctx`specify a Lua table to be the [ngx.ctx](https://github.com/openresty/lua-nginx-module#ngxctx) table for the subrequest. It can be the current request's [ngx.ctx](https://github.com/openresty/lua-nginx-module#ngxctx) table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the `v0.3.1rc25` release.
- `vars`take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the `v0.3.1rc31` release.
- `copy_all_vars`specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the `v0.3.1rc31` release.
- `share_all_vars`specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing.
- `always_forward_body`when set to true, the current (parent) request's request body will always be forwarded to the subrequest being created if the `body` option is not specified. The request body read by either [ngx.req.read_body()](https://github.com/openresty/lua-nginx-module#ngxreqread_body) or [lua_need_request_body on](https://github.com/openresty/lua-nginx-module#lua_need_request_body) will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest (no matter the request body data is buffered in memory buffers or temporary files). By default, this option is `false` and when the `body` option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the `PUT` or `POST` request method.

Issuing a POST subrequest, for example, can be done as follows

```
 res = ngx.location.capture(
     '/foo/bar',
     { method = ngx.HTTP_POST, body = 'hello, world' }
 )
```

See HTTP method constants methods other than POST.The `method` option is `ngx.HTTP_GET` by default.

The `args` option can specify extra URI arguments, for instance,

```
 ngx.location.capture('/foo?a=1',
     { args = { b = 3, c = ':' } }
 )
```

is equivalent to

```
 ngx.location.capture('/foo?a=1&b=3&c=%3a')
```

that is, this method will escape argument keys and values according to URI rules andconcatenate them together into a complete query string. The format for the Lua table passed as the `args` argument is identical to the format used in the [ngx.encode_args](https://github.com/openresty/lua-nginx-module#ngxencode_args) method.

此方法会根据 URL 编码规则转义参数。

The `args` option can also take plain query strings:

```
 ngx.location.capture('/foo?a=1',
     { args = 'b=3&c=%3a' } }
 )
```

This is functionally identical to the previous examples.

The `share_all_vars` option controls whether to share nginx variables among the current request and its subrequests.If this option is set to `true`, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.

Care should be taken in using this option as variable scope sharing can have unexpected side effects. The `args`, `vars`, or `copy_all_vars` options are generally preferable instead.

This option is set to `false` by default

```
 location /other {
     set $dog "$dog world";
     echo "$uri dog: $dog";
 }

 location /lua {
     set $dog 'hello';
     content_by_lua_block {
         res = ngx.location.capture("/other",
             { share_all_vars = true });

         ngx.print(res.body)
         ngx.say(ngx.var.uri, ": ", ngx.var.dog)
     }
 }
```

Accessing location `/lua` gives

```
/other dog: hello world
/lua: hello world

```

The `copy_all_vars` option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.

```
 location /other {
     set $dog "$dog world";
     echo "$uri dog: $dog";
 }

 location /lua {
     set $dog 'hello';
     content_by_lua_block {
         res = ngx.location.capture("/other",
             { copy_all_vars = true });

         ngx.print(res.body)
         ngx.say(ngx.var.uri, ": ", ngx.var.dog)
     }
 }
```

Request `GET /lua` will give the output

```
/other dog: hello world
/lua: hello

```

Note that if both `share_all_vars` and `copy_all_vars` are set to true, then `share_all_vars` takes precedence.

注意：如果同时设置了 `share_all_vars` 和 `copy_all_vars`，`share_all_vars` 会优先。

In addition to the two settings above, it is possible to specify values for variables in the subrequest using the `vars` option. Thesevariables are set after the sharing or copying of variables has beenevaluated, and provides a more efficient method of passing specificvalues to a subrequest over encoding them as URL arguments andunescaping them in the Nginx config file.

也可以通过 `vars` 选项设置值,会在共享、复制变量执行之后。避免了先编码，在解码。

```
 location /other {
     content_by_lua_block {
         ngx.say("dog = ", ngx.var.dog)
         ngx.say("cat = ", ngx.var.cat)
     }
 }

 location /lua {
     set $dog '';
     set $cat '';
     content_by_lua_block {
         res = ngx.location.capture("/other",
             { vars = { dog = "hello", cat = 32 }});

         ngx.print(res.body)
     }
 }
```

Accessing `/lua` will yield the output

```
dog = hello
cat = 32

```

The `ctx` option can be used to specify a custom Lua table to serve as the [ngx.ctx](https://github.com/openresty/lua-nginx-module#ngxctx) table for the subrequest.

```
 location /sub {
     content_by_lua_block {
         ngx.ctx.foo = "bar";
     }
 }
 location /lua {
     content_by_lua_block {
         local ctx = {}
         res = ngx.location.capture("/sub", { ctx = ctx })

         ngx.say(ctx.foo);
         ngx.say(ngx.ctx.foo);
     }
 }
```

Then request `GET /lua` gives

```
bar
nil

```

It is also possible to use this `ctx` option to share the same [ngx.ctx](https://github.com/openresty/lua-nginx-module#ngxctx) table between the current (parent) request and the subrequest:

```
 location /sub {
     content_by_lua_block {
         ngx.ctx.foo = "bar";
     }
 }
 location /lua {
     content_by_lua_block {
         res = ngx.location.capture("/sub", { ctx = ngx.ctx })
         ngx.say(ngx.ctx.foo);
     }
 }
```

Request `GET /lua` yields the output

```
bar

```

Note that subrequests issued by [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) inherit all therequest headers of the current request by default and that this may have unexpected side effects on thesubrequest responses. For example, when using the standard `ngx_proxy` module to servesubrequests, an "Accept-Encoding: gzip" header in the main request may resultin gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting[proxy_pass_request_headers](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers) to `off` in subrequest locations.

注意：通过ngx.location.capture 的子请求会默认继承 父请求头。也可以通过在 子 location 中 proxy_pass_request_headers 设为 off 来不传递请求头。

When the `body` option is not specified and the `always_forward_body` option is false (the default value), the `POST` and `PUT` subrequests will inherit the request bodies of the parent request (if any).

当没有设置`body`和 `always_forward_body`时， POST 和 PUT 请求会继承父请求的请求体。

There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was `50` concurrent subrequests and in more recent versions, Nginx `1.1.x` onwards, this was increased to `200` concurrent subrequests. When this limit is exceeded, the following error message is added to the `error.log` file:

子请求的并发数有限制。

```
[error] 13983#0: *1 subrequests cycle while processing "/uri"

```

The limit can be manually modified if required by editing the definition of the `NGX_HTTP_MAX_SUBREQUESTS` macro in the `nginx/src/http/ngx_http_request.h` file in the Nginx source tree.

可以修改 nginx 源码来改变。

Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules](https://github.com/openresty/lua-nginx-module#locations-configured-by-subrequest-directives-of-other-modules).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.location.capture_multi

**syntax:** *res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Just like [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture), but supports multiple subrequests running in parallel.

This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,

支持多个子请求并行。

```
 res1, res2, res3 = ngx.location.capture_multi{
     { "/foo", { args = "a=3&b=4" } },
     { "/bar" },
     { "/baz", { method = ngx.HTTP_POST, body = "hello" } },
 }

 if res1.status == ngx.HTTP_OK then
     ...
 end

 if res2.body == "BLAH" then
     ...
 end
```

This function will not return until all the subrequests terminate.The total latency is the longest latency of the individual subrequests rather than the sum.

请求的时间为最长的那一个。

Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:

可以使用 lua table 来记录所有的请求 和 响应。

```
 -- construct the requests table
 local reqs = {}
 table.insert(reqs, { "/mysql" })
 table.insert(reqs, { "/postgres" })
 table.insert(reqs, { "/redis" })
 table.insert(reqs, { "/memcached" })

 -- issue all the requests at once and wait until they all return
 local resps = { ngx.location.capture_multi(reqs) }

 -- loop over the responses table
 for i, resp in ipairs(resps) do
     -- process the response table "resp"
 end
```

The [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) function is just a special formof this function. Logically speaking, the [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) can be implemented like this

```
 ngx.location.capture =
     function (uri, args)
         return ngx.location.capture_multi({ {uri, args} })
     end
```

Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules](https://github.com/openresty/lua-nginx-module#locations-configured-by-subrequest-directives-of-other-modules).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.status

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Read and write the current request's response status. This should be calledbefore sending out the response headers.

读写当前请求的响应状态，应该在发送响应头之前进行操作。

```
 ngx.status = ngx.HTTP_CREATED
 status = ngx.status
```

Setting `ngx.status` after the response header is sent out has no effect but leaving an error message in your nginx's error log file:

```
attempt to set ngx.status after sending out response headers

```

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.header.HEADER

**syntax:** *ngx.header.HEADER = VALUE*

**syntax:** *value = ngx.header.HEADER*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Set, add to, or clear the current request's `HEADER` response header that is to be sent.

设置、添加、清除当前请求头、响应头。

Underscores (`_`) in the header names will be replaced by hyphens (`-`) by default. This transformation can be turned off via the [lua_transform_underscores_in_response_headers](https://github.com/openresty/lua-nginx-module#lua_transform_underscores_in_response_headers) directive.

头名称中的 下划线会被转为 -。可以通过指令关闭。

The header names are matched case-insensitively.

头名称的匹配是忽略大小写的。

```
 -- equivalent to ngx.header["Content-Type"] = 'text/plain'
 ngx.header.content_type = 'text/plain';

 ngx.header["X-My-Header"] = 'blah blah';
```

Multi-value headers can be set this way:

```
 ngx.header['Set-Cookie'] = {'a=32; path=/', 'b=4; path=/'}
```

will yield

```
 Set-Cookie: a=32; path=/
 Set-Cookie: b=4; path=/
```

in the response headers.

Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as `Content-Type` that only accept a single value).

对于单值的头字段，使用 lua tables 时，只会接收最后一个元素。

```
 ngx.header.content_type = {'a', 'b'}
```

is equivalent to

```
 ngx.header.content_type = 'b'
```

Setting a slot to `nil` effectively removes it from the response headers:

设为 nuil 时，表示移除字段。

```
 ngx.header["X-My-Header"] = nil;
```

The same applies to assigning an empty table:

```
 ngx.header["X-My-Header"] = {};
```

Setting `ngx.header.HEADER` after sending out response headers (either explicitly with [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers) or implicitly with [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint) and similar) will throw out a Lua exception.

在显示或隐式发送了请求头之后，进行修改会引起 Lua 异常。

Reading `ngx.header.HEADER` will return the value of the response header named `HEADER`.

Underscores (`_`) in the header names will also be replaced by dashes (`-`) and the header names will be matched case-insensitively. If the response header is not present at all, `nil` will be returned.

This is particularly useful in the context of [header_filter_by_lua*](https://github.com/openresty/lua-nginx-module#header_filter_by_lua), for example,

```
 location /test {
     set $footer '';

     proxy_pass http://some-backend;

     header_filter_by_lua_block {
         if ngx.header["X-My-Header"] == "blah" then
             ngx.var.footer = "some value"
         end
     }

     echo_after_body $footer;
 }
```

For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers

```
Foo: bar
Foo: baz

```

will result in

```
 {"bar", "baz"}
```

to be returned when reading `ngx.header.Foo`.

Note that `ngx.header` is not a normal Lua table and as such, it is not possible to iterate through it using the Lua `ipairs` function.

与lua 的 table 不同，不能使用 lua 的 upairs 进行迭代。

For reading *request* headers, use the [ngx.req.get_headers](https://github.com/openresty/lua-nginx-module#ngxreqget_headers) function instead.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.resp.get_headers

**syntax:** *headers = ngx.resp.get_headers(max_headers?, raw?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua**

Returns a Lua table holding all the current response headers for the current request.

返回持有当前请求响应头的 lua table

```
 local h = ngx.resp.get_headers()
 for k, v in pairs(h) do
     ...
 end
```

This function has the same signature as [ngx.req.get_headers](https://github.com/openresty/lua-nginx-module#ngxreqget_headers) except getting response headers instead of request headers.

This API was first introduced in the `v0.9.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.is_internal

**syntax:** *is_internal = ngx.req.is_internal()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Returns a boolean indicating whether the current request is an "internal request", i.e.,a request initiated from inside the current nginx server instead of from the client side.

返回当前请求是否为内部请求的标志。

Subrequests are all internal requests and so are requests after internal redirects.

This API was first introduced in the `v0.9.20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.start_time

**syntax:** *secs = ngx.req.start_time()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.

返回请求创建的时间戳。

The following example emulates the `$request_time` variable value (provided by [ngx_http_log_module](http://nginx.org/en/docs/http/ngx_http_log_module.html)) in pure Lua:

```
 local request_time = ngx.now() - ngx.req.start_time()
```

This function was first introduced in the `v0.7.7` release.

See also [ngx.now](https://github.com/openresty/lua-nginx-module#ngxnow) and [ngx.update_time](https://github.com/openresty/lua-nginx-module#ngxupdate_time).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.http_version

**syntax:** *num = ngx.req.http_version()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua**

Returns the HTTP version number for the current request as a Lua number.

返回当前 http 协议版本。

Current possible values are 2.0, 1.0, 1.1, and 0.9. Returns `nil` for unrecognized values.

This method was first introduced in the `v0.7.17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.raw_header

**syntax:** *str = ngx.req.raw_header(no_request_line?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua**

Returns the original raw HTTP protocol header received by the Nginx server.

返回 http 请求的原始请求头。

By default, the request line and trailing `CR LF` terminator will also be included. For example,

```
 ngx.print(ngx.req.raw_header())
```

gives something like this:

```
GET /t HTTP/1.1
Host: localhost
Connection: close
Foo: bar

```

You can specify the optional`no_request_line` argument as a `true` value to exclude the request line from the result. For example,

通过参数也可以排除请求行。


```
 ngx.print(ngx.req.raw_header(true))
```

outputs something like this:

```
Host: localhost
Connection: close
Foo: bar

```

This method was first introduced in the `v0.7.17` release.

This method does not work in HTTP/2 requests yet.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.get_method

**syntax:** *method_name = ngx.req.get_method()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, balancer_by_lua**

Retrieves the current request's request method name. Strings like `"GET"` and `"POST"` are returned instead of numerical [method constants](https://github.com/openresty/lua-nginx-module#http-method-constants).

返回请求的方法

If the current request is an Nginx subrequest, then the subrequest's method name will be returned.

This method was first introduced in the `v0.5.6` release.

See also [ngx.req.set_method](https://github.com/openresty/lua-nginx-module#ngxreqset_method).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.set_method

**syntax:** *ngx.req.set_method(method_id)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua**

Overrides the current request's request method with the `method_id` argument. Currently only numerical [method constants](https://github.com/openresty/lua-nginx-module#http-method-constants) are supported, like `ngx.HTTP_POST` and `ngx.HTTP_GET`.

覆盖当前请求的方法。

If the current request is an Nginx subrequest, then the subrequest's method will be overridden.

This method was first introduced in the `v0.5.6` release.

See also [ngx.req.get_method](https://github.com/openresty/lua-nginx-module#ngxreqget_method).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.set_uri

**syntax:** *ngx.req.set_uri(uri, jump?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua**

Rewrite the current request's (parsed) URI by the `uri` argument. The `uri` argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.

重新设置当前请求的 uri 参数。

The optional boolean `jump` argument can trigger location rematch (or location jump) as [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html)'s [rewrite](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite) directive, that is, when `jump` is `true` (default to `false`), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later `post-rewrite` phase and jumping to the new location.

jump 参数会触发重新匹配。

Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior. This function will return but with no returned values when the `jump` argument is `false` or absent altogether.

For example, the following nginx config snippet

```
 rewrite ^ /foo last;
```

can be coded in Lua like this:

```
 ngx.req.set_uri("/foo", true)
```

Similarly, Nginx config

```
 rewrite ^ /foo break;
```

can be coded in Lua as

```
 ngx.req.set_uri("/foo", false)
```

or equivalently,

```
 ngx.req.set_uri("/foo")
```

The `jump` argument can only be set to `true` in [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua). Use of jump in other contexts is prohibited and will throw out a Lua exception.

jump 参数只能在 rewrite_by_lua* 阶段进行设置。

A more sophisticated example involving regex substitutions is as follows

```
 location /test {
     rewrite_by_lua_block {
         local uri = ngx.re.sub(ngx.var.uri, "^/test/(.*)", "/$1", "o")
         ngx.req.set_uri(uri)
     }
     proxy_pass http://my_backend;
 }
```

which is functionally equivalent to

```
 location /test {
     rewrite ^/test/(.*) /$1 break;
     proxy_pass http://my_backend;
 }
```

Note that it is not possible to use this interface to rewrite URI arguments and that [ngx.req.set_uri_args](https://github.com/openresty/lua-nginx-module#ngxreqset_uri_args) should be used for this instead. For instance, Nginx config

```
 rewrite ^ /foo?a=3? last;
```

can be coded as

```
 ngx.req.set_uri_args("a=3")
 ngx.req.set_uri("/foo", true)
```

or

```
 ngx.req.set_uri_args({a = 3})
 ngx.req.set_uri("/foo", true)
```

This interface was first introduced in the `v0.3.1rc14` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.set_uri_args

**syntax:** *ngx.req.set_uri_args(args)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua**

Rewrite the current request's URI query arguments by the `args` argument. The `args` argument can be either a Lua string, as in

重写当前请求的查询参数，可以是 lua 字符串（url 编码），或是 lua table。

```
 ngx.req.set_uri_args("a=3&b=hello%20world")
```

or a Lua table holding the query arguments' key-value pairs, as in

```
 ngx.req.set_uri_args({ a = 3, b = "hello world" })
```

where in the latter case, this method will escape argument keys and values according to the URI escaping rule.

Multi-value arguments are also supported:

```
 ngx.req.set_uri_args({ a = 3, b = {5, 6} })
```

which will result in a query string like `a=3&b=5&b=6`.

This interface was first introduced in the `v0.3.1rc13` release.

See also [ngx.req.set_uri](https://github.com/openresty/lua-nginx-module#ngxreqset_uri).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.get_uri_args

**syntax:** *args = ngx.req.get_uri_args(max_args?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua**

Returns a Lua table holding all the current request URL query arguments.

以 lua table 获取当前请求的 查询参数。会 url 解码，没有值的 布尔处理为 true，与参数为空不同。

```
 location = /test {
     content_by_lua_block {
         local args = ngx.req.get_uri_args()
         for key, val in pairs(args) do
             if type(val) == "table" then
                 ngx.say(key, ": ", table.concat(val, ", "))
             else
                 ngx.say(key, ": ", val)
             end
         end
     }
 }
```

Then `GET /test?foo=bar&bar=baz&bar=blah` will yield the response body

```
 foo: bar
 bar: baz, blah
```

Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.

Keys and values are unescaped according to URI escaping rules. In the settings above, `GET /test?a%20b=1%61+2` will yield:

```
 a b: 1a 2
```

Arguments without the `=<value>` parts are treated as boolean arguments. `GET /test?foo&bar` will yield:

```
 foo: true
 bar: true
```

That is, they will take Lua boolean values `true`. However, they are different from arguments taking empty string values. `GET /test?foo=&bar=` will give something like

```
 foo:
 bar:
```

Empty key arguments are discarded. `GET /test?=hello&=world` will yield an empty output for instance.

Updating query arguments via the nginx variable `$args` (or `ngx.var.args` in Lua) at runtime is also supported:

```
 ngx.var.args = "a=3&b=42"
 local args = ngx.req.get_uri_args()
```

Here the `args` table will always look like

```
 {a = 3, b = 42}
```

regardless of the actual request query string.

Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.

However, the optional `max_args` function argument can be used to override this limit:

```
 local args = ngx.req.get_uri_args(10)
```

This argument can be set to zero to remove the limit and to process all request arguments received:

```
 local args = ngx.req.get_uri_args(0)
```

Removing the `max_args` cap is strongly discouraged.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.get_post_args

**syntax:** *args, err = ngx.req.get_post_args(max_args?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Returns a Lua table holding all the current request POST query arguments (of the MIME type `application/x-www-form-urlencoded`). Call [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body) to read the request body first or turn on the [lua_need_request_body](https://github.com/openresty/lua-nginx-module#lua_need_request_body) directive to avoid errors.

使用 lua table 获取 POST 的查询参数。注意先读取请求体。

```
 location = /test {
     content_by_lua_block {
         ngx.req.read_body()
         local args, err = ngx.req.get_post_args()
         if not args then
             ngx.say("failed to get post args: ", err)
             return
         end
         for key, val in pairs(args) do
             if type(val) == "table" then
                 ngx.say(key, ": ", table.concat(val, ", "))
             else
                 ngx.say(key, ": ", val)
             end
         end
     }
 }
```

Then

```
 # Post request with the body 'foo=bar&bar=baz&bar=blah'
 $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
```

will yield the response body like

```
 foo: bar
 bar: baz, blah
```

Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.

Keys and values will be unescaped according to URI escaping rules.

With the settings above,

```
 # POST request with body 'a%20b=1%61+2'
 $ curl -d 'a%20b=1%61+2' localhost/test
```

will yield:

```
 a b: 1a 2
```

Arguments without the `=<value>` parts are treated as boolean arguments. `POST /test` with the request body `foo&bar` will yield:

```
 foo: true
 bar: true
```

That is, they will take Lua boolean values `true`. However, they are different from arguments taking empty string values. `POST /test` with request body `foo=&bar=` will return something like

```
 foo:
 bar:
```

Empty key arguments are discarded. `POST /test` with body `=hello&=world` will yield empty outputs for instance.

Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.

However, the optional `max_args` function argument can be used to override this limit:

```
 local args = ngx.req.get_post_args(10)
```

This argument can be set to zero to remove the limit and to process all request arguments received:

```
 local args = ngx.req.get_post_args(0)
```

Removing the `max_args` cap is strongly discouraged.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.get_headers

**syntax:** *headers = ngx.req.get_headers(max_headers?, raw?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Returns a Lua table holding all the current request headers.

用 lua tabe 获取 当前的请求头。

```
 local h = ngx.req.get_headers()
 for k, v in pairs(h) do
     ...
 end
```

To read an individual header:

```
 ngx.say("Host: ", ngx.req.get_headers()["Host"])
```

Note that the [ngx.var.HEADER](https://github.com/openresty/lua-nginx-module#ngxvarvariable) API call, which uses core [$http_HEADER](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_) variables, may be more preferable for reading individual request headers.

For multiple instances of request headers such as:

```
 Foo: foo
 Foo: bar
 Foo: baz
```

the value of `ngx.req.get_headers()["Foo"]` will be a Lua (array) table such as:

```
 {"foo", "bar", "baz"}
```

Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks.

However, the optional `max_headers` function argument can be used to override this limit:

```
 local headers = ngx.req.get_headers(10)
```

This argument can be set to zero to remove the limit and to process all request headers received:

```
 local headers = ngx.req.get_headers(0)
```

Removing the `max_headers` cap is strongly discouraged.

Since the `0.6.9` release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the `raw` argument is set to `true` (default to `false`).

Also, by default, an `__index` metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header `My-Foo-Header` is present, then the following invocations will all pick up the value of this header correctly:

添加 __index 元方法将结果转为小写和 -

```
 ngx.say(headers.my_foo_header)
 ngx.say(headers["My-Foo-Header"])
 ngx.say(headers["my-foo-header"])
```

The `__index` metamethod will not be added when the `raw` argument is set to `true`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.set_header

**syntax:** *ngx.req.set_header(header_name, header_value)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua**

Set the current request's request header named `header_name` to value `header_value`, overriding any existing ones.

设置当前请求的请求头的值。

By default, all the subrequests subsequently initiated by [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) and [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi) will inherit the new header.

Here is an example of setting the `Content-Type` header:

```
 ngx.req.set_header("Content-Type", "text/css")
```

The `header_value` can take an array list of values,for example,

```
 ngx.req.set_header("Foo", {"a", "abc"})
```

will produce two new request headers:

```
 Foo: a
 Foo: abc
```

and old `Foo` headers will be overridden if there is any.

When the `header_value` argument is `nil`, the request header will be removed. So

```
 ngx.req.set_header("X-Foo", nil)
```

is equivalent to

```
 ngx.req.clear_header("X-Foo")
```

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.clear_header

**syntax:** *ngx.req.clear_header(header_name)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua**

Clears the current request's request header named `header_name`. None of the current request's existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default.

清除当前请求头中的某个字段。只影响新创建的子请求。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.read_body

**syntax:** *ngx.req.read_body()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Reads the client request body synchronously without blocking the Nginx event loop.

以不阻塞 nginx 事务循环的方式读取 客户端的 请求体。

```
 ngx.req.read_body()
 local args = ngx.req.get_post_args()
```

If the request body is already read previously by turning on [lua_need_request_body](https://github.com/openresty/lua-nginx-module#lua_need_request_body) or by using other modules, then this function does not run and returns immediately.

如果其他模块或函数读取了，此函数立即返回其值。

If the request body has already been explicitly discarded, either by the [ngx.req.discard_body](https://github.com/openresty/lua-nginx-module#ngxreqdiscard_body) function or other modules, this function does not run and returns immediately.

In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception *or* terminate the current request with a 500 status code immediately.

The request body data read using this function can be retrieved later via [ngx.req.get_body_data](https://github.com/openresty/lua-nginx-module#ngxreqget_body_data) or, alternatively, the temporary file name for the body data cached to disk using [ngx.req.get_body_file](https://github.com/openresty/lua-nginx-module#ngxreqget_body_file). This depends on

1. whether the current request body is already larger than the [client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size),
2. and whether [client_body_in_file_only](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only) has been switched on.

In cases where current request may have a request body and the request body data is not required, The [ngx.req.discard_body](https://github.com/openresty/lua-nginx-module#ngxreqdiscard_body) function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.

This function was first introduced in the `v0.3.1rc17` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.discard_body

**syntax:** *ngx.req.discard_body()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately (without using the request body by any means).

显示丢弃请求体。

This function is an asynchronous call and returns immediately.

这个函数时异步调用。

If the request body has already been read, this function does nothing and returns immediately.

如果已经读取请求体，此函数不做任何操作。

This function was first introduced in the `v0.3.1rc17` release.

See also [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.get_body_data

**syntax:** *data = ngx.req.get_body_data()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, log_by_lua**

Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the [ngx.req.get_post_args](https://github.com/openresty/lua-nginx-module#ngxreqget_post_args) function instead if a Lua table is required.

获得内存中的请求体。

This function returns `nil` if

1. the request body has not been read,
2. the request body has been read into disk temporary files,
3. or the request body has zero size.

If the request body has not been read yet, call [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body) first (or turned on [lua_need_request_body](https://github.com/openresty/lua-nginx-module#lua_need_request_body) to force this module to read the request body. This is not recommended however).

If the request body has been read into disk files, try calling the [ngx.req.get_body_file](https://github.com/openresty/lua-nginx-module#ngxreqget_body_file) function instead.

To force in-memory request bodies, try setting [client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size) to the same size value in [client_max_body_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size).

Note that calling this function instead of using `ngx.var.request_body` or `ngx.var.echo_request_body` is more efficient because it can save one dynamic memory allocation and one data copy.

使用此函数要比其他 var.* 更有效。

This function was first introduced in the `v0.3.1rc17` release.

See also [ngx.req.get_body_file](https://github.com/openresty/lua-nginx-module#ngxreqget_body_file).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.get_body_file

**syntax:** *file_name = ngx.req.get_body_file()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Retrieves the file name for the in-file request body data. Returns `nil` if the request body has not been read or has been read into memory.

The returned file is read only and is usually cleaned up by Nginx's memory pool. It should not be manually modified, renamed, or removed in Lua code.

If the request body has not been read yet, call [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body) first (or turned on [lua_need_request_body](https://github.com/openresty/lua-nginx-module#lua_need_request_body) to force this module to read the request body. This is not recommended however).

If the request body has been read into memory, try calling the [ngx.req.get_body_data](https://github.com/openresty/lua-nginx-module#ngxreqget_body_data) function instead.

To force in-file request bodies, try turning on [client_body_in_file_only](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only).

This function was first introduced in the `v0.3.1rc17` release.

See also [ngx.req.get_body_data](https://github.com/openresty/lua-nginx-module#ngxreqget_body_data).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.set_body_data

**syntax:** *ngx.req.set_body_data(data)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Set the current request's request body using the in-memory data specified by the `data` argument.

设置请求体的数据

If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.

This function was first introduced in the `v0.3.1rc18` release.

See also [ngx.req.set_body_file](https://github.com/openresty/lua-nginx-module#ngxreqset_body_file).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.set_body_file

**syntax:** *ngx.req.set_body_file(file_name, auto_clean?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Set the current request's request body using the in-file data specified by the `file_name` argument.

以文件设置请求体数据

If the optional `auto_clean` argument is given a `true` value, then this file will be removed at request completion or the next time this function or [ngx.req.set_body_data](https://github.com/openresty/lua-nginx-module#ngxreqset_body_data) are called in the same request. The `auto_clean` is default to `false`.

Please ensure that the file specified by the `file_name` argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.

If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.

This function was first introduced in the `v0.3.1rc18` release.

See also [ngx.req.set_body_data](https://github.com/openresty/lua-nginx-module#ngxreqset_body_data).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.init_body

**syntax:** *ngx.req.init_body(buffer_size?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua**

Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [ngx.req.append_body](https://github.com/openresty/lua-nginx-module#ngxreqappend_body) and [ngx.req.finish_body](https://github.com/openresty/lua-nginx-module#ngxreqfinish_body) APIs.

给当前请求设置一个新的请求体。

If the `buffer_size` argument is specified, then its value will be used for the size of the memory buffer for body writing with [ngx.req.append_body](https://github.com/openresty/lua-nginx-module#ngxreqappend_body). If the argument is omitted, then the value specified by the standard [client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size) directive will be used instead.

When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.

It is important to always call the [ngx.req.finish_body](https://github.com/openresty/lua-nginx-module#ngxreqfinish_body) after all the data has been appended onto the current request body. Also, when this function is used together with [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket), it is required to call [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket) *before* this function, or you will get the "request body already exists" error message.

The usage of this function is often like this:

```
 ngx.req.init_body(128 * 1024)  -- buffer is 128KB
 for chunk in next_data_chunk() do
     ngx.req.append_body(chunk) -- each chunk can be 4KB
 end
 ngx.req.finish_body()
```

This function can be used with [ngx.req.append_body](https://github.com/openresty/lua-nginx-module#ngxreqappend_body), [ngx.req.finish_body](https://github.com/openresty/lua-nginx-module#ngxreqfinish_body), and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket) to implement efficient input filters in pure Lua (in the context of [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) or [access_by_lua*](https://github.com/openresty/lua-nginx-module#access_by_lua)), which can be used with other Nginx content handler or upstream modules like [ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html) and [ngx_http_fastcgi_module](http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html).

This function was first introduced in the `v0.5.11` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.append_body

**syntax:** *ngx.req.append_body(data_chunk)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua**

Append new data chunk specified by the `data_chunk` argument onto the existing request body created by the [ngx.req.init_body](https://github.com/openresty/lua-nginx-module#ngxreqinit_body) call.

When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.

It is important to always call the [ngx.req.finish_body](https://github.com/openresty/lua-nginx-module#ngxreqfinish_body) after all the data has been appended onto the current request body.

This function can be used with [ngx.req.init_body](https://github.com/openresty/lua-nginx-module#ngxreqinit_body), [ngx.req.finish_body](https://github.com/openresty/lua-nginx-module#ngxreqfinish_body), and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket) to implement efficient input filters in pure Lua (in the context of [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) or [access_by_lua*](https://github.com/openresty/lua-nginx-module#access_by_lua)), which can be used with other Nginx content handler or upstream modules like [ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html) and [ngx_http_fastcgi_module](http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html).

This function was first introduced in the `v0.5.11` release.

See also [ngx.req.init_body](https://github.com/openresty/lua-nginx-module#ngxreqinit_body).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.finish_body

**syntax:** *ngx.req.finish_body()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua**

Completes the construction process of the new request body created by the [ngx.req.init_body](https://github.com/openresty/lua-nginx-module#ngxreqinit_body) and [ngx.req.append_body](https://github.com/openresty/lua-nginx-module#ngxreqappend_body) calls.

This function can be used with [ngx.req.init_body](https://github.com/openresty/lua-nginx-module#ngxreqinit_body), [ngx.req.append_body](https://github.com/openresty/lua-nginx-module#ngxreqappend_body), and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket) to implement efficient input filters in pure Lua (in the context of [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) or [access_by_lua*](https://github.com/openresty/lua-nginx-module#access_by_lua)), which can be used with other Nginx content handler or upstream modules like [ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html) and [ngx_http_fastcgi_module](http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html).

This function was first introduced in the `v0.5.11` release.

See also [ngx.req.init_body](https://github.com/openresty/lua-nginx-module#ngxreqinit_body).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.req.socket

**syntax:** *tcpsock, err = ngx.req.socket()*

**syntax:** *tcpsock, err = ngx.req.socket(raw)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Returns a read-only cosocket object that wraps the downstream connection. Only [receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive) and [receiveuntil](https://github.com/openresty/lua-nginx-module#tcpsockreceiveuntil) methods are supported on this object.

返回一个包含下游连接的只读 cosock 对象。

In case of error, `nil` will be returned as well as a string describing the error.

The socket object returned by this method is usually used to read the current request's body in a streaming fashion. Do not turn on the [lua_need_request_body](https://github.com/openresty/lua-nginx-module#lua_need_request_body) directive, and do not mix this call with [ngx.req.read_body](https://github.com/openresty/lua-nginx-module#ngxreqread_body) and [ngx.req.discard_body](https://github.com/openresty/lua-nginx-module#ngxreqdiscard_body).

If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading.Chunked request bodies are not yet supported in this API.

Since the `v0.9.0` release, this function accepts an optional boolean `raw` argument. When this argument is `true`, this function returns a full-duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the [receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive), [receiveuntil](https://github.com/openresty/lua-nginx-module#tcpsockreceiveuntil), and [send](https://github.com/openresty/lua-nginx-module#tcpsocksend) methods.

When the `raw` argument is `true`, it is required that no pending data from any previous [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay), [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint), or [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers) calls exists. So if you have these downstream output calls previously, you should call [ngx.flush(true)](https://github.com/openresty/lua-nginx-module#ngxflush) before calling `ngx.req.socket(true)` to ensure that there is no pending output data. If the request body has not been read yet, then this "raw socket" can also be used to read the request body.

You can use the "raw request socket" returned by `ngx.req.socket(true)` to implement fancy protocols like [WebSocket](http://en.wikipedia.org/wiki/WebSocket), or just emit your own raw HTTP response header or body data. You can refer to the [lua-resty-websocket library](https://github.com/openresty/lua-resty-websocket) for a real world example.

This function was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.exec

**syntax:** *ngx.exec(uri, args?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Does an internal redirect to `uri` with `args` and is similar to the [echo_exec](http://github.com/openresty/echo-nginx-module#echo_exec) directive of the [echo-nginx-module](http://github.com/openresty/echo-nginx-module).

使用 uri 和 args 做一个内部重定向。

```
 ngx.exec('/some-location');
 ngx.exec('/some-location', 'a=3&b=5&c=6');
 ngx.exec('/some-location?a=3&b=5', 'c=6');
```

The optional second `args` can be used to specify extra URI query arguments, for example:

```
 ngx.exec("/foo", "a=3&b=hello%20world")
```

Alternatively, a Lua table can be passed for the `args` argument for ngx_lua to carry out URI escaping and string concatenation.

```
 ngx.exec("/foo", { a = 3, b = "hello world" })
```

The result is exactly the same as the previous example.

The format for the Lua table passed as the `args` argument is identical to the format used in the [ngx.encode_args](https://github.com/openresty/lua-nginx-module#ngxencode_args) method.

Named locations are also supported but the second `args` argument will be ignored if present and the querystring for the new target is inherited from the referring location (if any).

支持命名的 locations , args 的参数会被忽略。查询的参数会从引用的locations 继承。

`GET /foo/file.php?a=hello` will return "hello" and not "goodbye" in the example below

```
 location /foo {
     content_by_lua_block {
         ngx.exec("@bar", "a=goodbye");
     }
 }

 location @bar {
     content_by_lua_block {
         local args = ngx.req.get_uri_args()
         for key, val in pairs(args) do
             if key == "a" then
                 ngx.say(val)
             end
         end
     }
 }
```

Note that the `ngx.exec` method is different from [ngx.redirect](https://github.com/openresty/lua-nginx-module#ngxredirect) in thatit is purely an internal redirect and that no new external HTTP traffic is involved.

Also note that this method call terminates the processing of the current request and that it *must* be called before [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers) or explicit response bodyoutputs by either [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint) or [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay).

注意： 这个方法会终止当前请求。应该在ngx.send_headers 调用之前。

It is recommended that a coding style that combines this method call with the `return` statement, i.e., `return ngx.exec(...)` be adopted when this method call is used in contexts other than [header_filter_by_lua*](https://github.com/openresty/lua-nginx-module#header_filter_by_lua) to reinforce the fact that the request processing is being terminated.

编程规范使用 与 return结合的方式，来终止当前的请求。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.redirect

**syntax:** *ngx.redirect(uri, status?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Issue an `HTTP 301` or `302` redirection to `uri`.

使用 HTTP 的301 302 重定向。

The optional `status` parameter specifies the HTTP status code to be used. The following status codes are supported right now:

- `301`
- `302` (default)
- `303`
- `307`

It is `302` (`ngx.HTTP_MOVED_TEMPORARILY`) by default.

Here is an example assuming the current server name is `localhost` and that it is listening on port 1984:

```
 return ngx.redirect("/foo")
```

which is equivalent to

```
 return ngx.redirect("/foo", ngx.HTTP_MOVED_TEMPORARILY)
```

Redirecting arbitrary external URLs is also supported, for example:

```
 return ngx.redirect("http://www.google.com")
```

We can also use the numerical code directly as the second `status` argument:

```
 return ngx.redirect("/foo", 301)
```

This method is similar to the [rewrite](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite) directive with the `redirect` modifier in the standard[ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html), for example, this `nginx.conf` snippet

```
 rewrite ^ /foo? redirect;  # nginx config
```

is equivalent to the following Lua code

```
 return ngx.redirect('/foo');  -- Lua code
```

while

```
 rewrite ^ /foo? permanent;  # nginx config
```

is equivalent to

```
 return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
```

URI arguments can be specified as well, for example:

```
 return ngx.redirect('/foo?a=3&b=4')
```

Note that this method call terminates the processing of the current request and that it *must* be called before [ngx.send_headers](https://github.com/openresty/lua-nginx-module#ngxsend_headers) or explicit response bodyoutputs by either [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint) or [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay).

与 ngx.exec 类似，也会终止当前请求

It is recommended that a coding style that combines this method call with the `return` statement, i.e., `return ngx.redirect(...)` be adopted when this method call is used in contexts other than [header_filter_by_lua*](https://github.com/openresty/lua-nginx-module#header_filter_by_lua) to reinforce the fact that the request processing is being terminated.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.send_headers

**syntax:** *ok, err = ngx.send_headers()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Explicitly send out the response headers.

显示的调用去发送请求头。

Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.

Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers outbefore content is output with [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay) or [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint) or when [content_by_lua*](https://github.com/openresty/lua-nginx-module#content_by_lua) exits normally.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.headers_sent

**syntax:** *value = ngx.headers_sent*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua**

Returns `true` if the response headers have been sent (by ngx_lua), and `false` otherwise.

判断是否发送了响应头。

This API was first introduced in ngx_lua v0.3.1rc6.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.print

**syntax:** *ok, err = ngx.print(...)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.

用于给客户端发送数据。

Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.

Lua `nil` values will output `"nil"` strings and Lua boolean values will output `"true"` and `"false"` literal strings respectively.

Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:

```
 local table = {
     "hello, ",
     {"world: ", true, " or ", false,
         {": ", nil}}
 }
 ngx.print(table)
```

will yield the output

```
 hello, world: true or false: nil
```

Non-array table arguments will cause a Lua exception to be thrown.

The `ngx.null` constant will yield the `"null"` string output.

This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call `ngx.flush(true)` after calling `ngx.print`. This can be particularly useful for streaming output. See [ngx.flush](https://github.com/openresty/lua-nginx-module#ngxflush) for more details.

这是一个异步调用，如果想同步调用，在之后调用 ngx.flush(true)

Please note that both `ngx.print` and [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay) will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.

注意：会影响整个输出链

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.say

**syntax:** *ok, err = ngx.say(...)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Just as [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint) but also emit a trailing newline.

与 ngx.print 的区别在于，没有结尾的新行。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.log

**syntax:** *ngx.log(log_level, ...)*

**context:** *init_by_lua\*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Log arguments concatenated to error.log with the given logging level.

输出到错误日志

Lua `nil` arguments are accepted and result in literal `"nil"` string while Lua booleans result in literal `"true"` or `"false"` string outputs. And the `ngx.null` constant will yield the `"null"` string output.

The `log_level` argument can take constants like `ngx.ERR` and `ngx.WARN`. Check out [Nginx log level constants](https://github.com/openresty/lua-nginx-module#nginx-log-level-constants) for details.

There is a hard coded `2048` byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the `NGX_MAX_ERROR_STR` macro definition in the `src/core/ngx_log.h` file in the Nginx source tree.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.flush

**syntax:** *ok, err = ngx.flush(wait?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Flushes response output to the client.

刷新响应体到客户端。参数决定同步、异步。

`ngx.flush` accepts an optional boolean `wait` argument (Default: `false`) first introduced in the `v0.3.1rc34` release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the `wait` argument set to `true` switches to synchronous mode.

In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the [send_timeout](http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout) setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.

When `ngx.flush(true)` is called immediately after [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint) or [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay), it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.

Note that `ngx.flush` is not functional when in the HTTP 1.0 output buffering mode. See [HTTP 1.0 support](https://github.com/openresty/lua-nginx-module#http-10-support).

Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.exit

**syntax:** *ngx.exit(status)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, header_filter_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

When `status >= 200` (i.e., `ngx.HTTP_OK` and above), it will interrupt the execution of the current request and return status code to nginx.

立即返回

When `status == 0` (i.e., `ngx.OK`), it will only quit the current phase handler (or the content handler if the [content_by_lua*](https://github.com/openresty/lua-nginx-module#content_by_lua) directive is used) and continue to run later phases (if any) for the current request.

结束当前阶段。

The `status` argument can be `ngx.OK`, `ngx.ERROR`, `ngx.HTTP_NOT_FOUND`,`ngx.HTTP_MOVED_TEMPORARILY`, or other [HTTP status constants](https://github.com/openresty/lua-nginx-module#http-status-constants).

To return an error page with custom contents, use code snippets like this:

```
 ngx.status = ngx.HTTP_GONE
 ngx.say("This is our own content")
 -- to cause quit the whole request rather than the current phase handler
 ngx.exit(ngx.HTTP_OK)
```

The effect in action:

```
 $ curl -i http://localhost/test
 HTTP/1.1 410 Gone
 Server: nginx/1.0.6
 Date: Thu, 15 Sep 2011 00:51:48 GMT
 Content-Type: text/plain
 Transfer-Encoding: chunked
 Connection: keep-alive

 This is our own content
```

Number literals can be used directly as the argument, for instance,

```
 ngx.exit(501)
```

Note that while this method accepts all [HTTP status constants](https://github.com/openresty/lua-nginx-module#http-status-constants) as input, it only accepts `NGX_OK` and `NGX_ERROR` of the [core constants](https://github.com/openresty/lua-nginx-module#core-constants).

Also note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the `return` statement, i.e., `return ngx.exit(...)` be used to reinforce the fact that the request processing is being terminated.

When being used in the contexts of [header_filter_by_lua*](https://github.com/openresty/lua-nginx-module#header_filter_by_lua), [balancer_by_lua*](https://github.com/openresty/lua-nginx-module#balancer_by_lua_block), and[ssl_session_store_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_block), `ngx.exit()` isan asynchronous operation and will return immediately. This behavior may change in future and it is recommended that users always use `return` in combination as suggested above.

由于是异步调用，推荐与 return 结合。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.eof

**syntax:** *ok, err = ngx.eof()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the "last chunk".

显示指明结束。

When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on well written HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:

```
 location = /async {
     keepalive_timeout 0;
     content_by_lua_block {
         ngx.say("got the task!")
         ngx.eof()  -- well written HTTP clients will close the connection at this point
         -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...
     }
 }
```

But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard [ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html) will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the [proxy_ignore_client_abort](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort) directive in your location block configured by [ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html):

```
 proxy_ignore_client_abort on;
```

A better way to do background jobs is to use the [ngx.timer.at](https://github.com/openresty/lua-nginx-module#ngxtimerat) API.

Since `v0.8.3` this function returns `1` on success, or returns `nil` and a string describing the error otherwise.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.sleep

**syntax:** *ngx.sleep(seconds)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).

Behind the scene, this method makes use of the Nginx timers.

Since the `0.7.20` release, The `0` time argument can also be specified.

This method was introduced in the `0.5.0rc30` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.escape_uri

**syntax:** *newstr = ngx.escape_uri(str)*

**context:** *init_by_lua\*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Escape `str` as a URI component.

将字符串url 编码

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.unescape_uri

**syntax:** *newstr = ngx.unescape_uri(str)*

**context:** *init_by_lua\*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua**

Unescape `str` as an escaped URI component.

url 解码。

For example,

```
 ngx.say(ngx.unescape_uri("b%20r56+7"))
```

gives the output

```
b r56 7

```

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.encode_args

**syntax:** *str = ngx.encode_args(table)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua**

Encode the Lua table to a query args string according to the URI encoded rules.

对 lua table 中的查询参数进行 url 编码

For example,

```
 ngx.encode_args({foo = 3, ["b r"] = "hello world"})
```

yields

```
foo=3&b%20r=hello%20world

```

The table keys must be Lua strings.

Multi-value query args are also supported. Just use a Lua table for the argument's value, for example:

```
 ngx.encode_args({baz = {32, "hello"}})
```

gives

```
baz=32&baz=hello

```

If the value table is empty and the effect is equivalent to the `nil` value.

Boolean argument values are also supported, for instance,

```
 ngx.encode_args({a = true, b = 1})
```

yields

```
a&b=1

```

If the argument value is `false`, then the effect is equivalent to the `nil` value.

This method was first introduced in the `v0.3.1rc27` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.decode_args

**syntax:** *table = ngx.decode_args(str, max_args?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Decodes a URI encoded query-string into a Lua table. This is the inverse function of [ngx.encode_args](https://github.com/openresty/lua-nginx-module#ngxencode_args).

将查询的url 编码字符串转为 lua table。

The optional `max_args` argument can be used to specify the maximum number of arguments parsed from the `str` argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks.

This argument can be set to zero to remove the limit and to process all request arguments received:

```
 local args = ngx.decode_args(str, 0)
```

Removing the `max_args` cap is strongly discouraged.

This method was introduced in the `v0.5.0rc29`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.encode_base64

**syntax:** *newstr = ngx.encode_base64(str, no_padding?)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Encodes `str` to a base64 digest.

将 str 进行 base64

Since the `0.9.16` release, an optional boolean-typed `no_padding` argument can be specified to control whether the base64 padding should be appended to the resulting digest (default to `false`, i.e., with padding enabled).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.decode_base64

**syntax:** *newstr = ngx.decode_base64(str)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Decodes the `str` argument as a base64 digest to the raw form. Returns `nil` if `str` is not well formed.

base64 解码。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.crc32_short

**syntax:** *intval = ngx.crc32_short(str)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Calculates the CRC-32 (Cyclic Redundancy Code) digest for the `str` argument.

crc 校验

This method performs better on relatively short `str` inputs (i.e., less than 30 ~ 60 bytes), as compared to [ngx.crc32_long](https://github.com/openresty/lua-nginx-module#ngxcrc32_long). The result is exactly the same as [ngx.crc32_long](https://github.com/openresty/lua-nginx-module#ngxcrc32_long).

Behind the scene, it is just a thin wrapper around the `ngx_crc32_short` function defined in the Nginx core.

This API was first introduced in the `v0.3.1rc8` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.crc32_long

**syntax:** *intval = ngx.crc32_long(str)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Calculates the CRC-32 (Cyclic Redundancy Code) digest for the `str` argument.

This method performs better on relatively long `str` inputs (i.e., longer than 30 ~ 60 bytes), as compared to [ngx.crc32_short](https://github.com/openresty/lua-nginx-module#ngxcrc32_short).  The result is exactly the same as [ngx.crc32_short](https://github.com/openresty/lua-nginx-module#ngxcrc32_short).

Behind the scene, it is just a thin wrapper around the `ngx_crc32_long` function defined in the Nginx core.

This API was first introduced in the `v0.3.1rc8` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.hmac_sha1

**syntax:** *digest = ngx.hmac_sha1(secret_key, str)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Computes the [HMAC-SHA1](http://en.wikipedia.org/wiki/HMAC) digest of the argument `str` and turns the result using the secret key `<secret_key>`.


The raw binary form of the `HMAC-SHA1` digest will be generated, use [ngx.encode_base64](https://github.com/openresty/lua-nginx-module#ngxencode_base64), for example, to encode the result to a textual representation if desired.

For example,

```
 local key = "thisisverysecretstuff"
 local src = "some string we want to sign"
 local digest = ngx.hmac_sha1(key, src)
 ngx.say(ngx.encode_base64(digest))
```

yields the output

```
R/pvxzHC4NLtj7S+kXFg/NePTmk=

```

This API requires the OpenSSL library enabled in the Nginx build (usually by passing the `--with-http_ssl_module` option to the `./configure` script).

This function was first introduced in the `v0.3.1rc29` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.md5

**syntax:** *digest = ngx.md5(str)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the hexadecimal representation of the MD5 digest of the `str` argument.

For example,

```
 location = /md5 {
     content_by_lua_block { ngx.say(ngx.md5("hello")) }
 }
```

yields the output

```
5d41402abc4b2a76b9719d911017c592

```

See [ngx.md5_bin](https://github.com/openresty/lua-nginx-module#ngxmd5_bin) if the raw binary MD5 digest is required.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.md5_bin

**syntax:** *digest = ngx.md5_bin(str)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the binary form of the MD5 digest of the `str` argument.

See [ngx.md5](https://github.com/openresty/lua-nginx-module#ngxmd5) if the hexadecimal form of the MD5 digest is required.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.sha1_bin

**syntax:** *digest = ngx.sha1_bin(str)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the binary form of the SHA-1 digest of the `str` argument.

This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).

This function was first introduced in the `v0.5.0rc6`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.quote_sql_str

**syntax:** *quoted_value = ngx.quote_sql_str(raw_value)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns a quoted SQL string literal according to the MySQL quoting rules.

将mysql 的语句字符串化。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.today

**syntax:** *str = ngx.today()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns current date (in the format `yyyy-mm-dd`) from the nginx cached time (no syscall involved unlike Lua's date library).

返回缓存的当前时间。

This is the local time.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.time

**syntax:** *secs = ngx.time()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).

返回时间戳。

Updates of the Nginx time cache can be forced by calling [ngx.update_time](https://github.com/openresty/lua-nginx-module#ngxupdate_time) first.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.now

**syntax:** *secs = ngx.now()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).

浮点数返回时间戳，更精确。最好先调用update_time

You can forcibly update the Nginx time cache by calling [ngx.update_time](https://github.com/openresty/lua-nginx-module#ngxupdate_time) first.

This API was first introduced in `v0.3.1rc32`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.update_time

**syntax:** *ngx.update_time()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.

This API was first introduced in `v0.3.1rc32`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.localtime

**syntax:** *str = ngx.localtime()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the current time stamp (in the format `yyyy-mm-dd hh:mm:ss`) of the nginx cached time (no syscall involved unlike Lua's [os.date](http://www.lua.org/manual/5.1/manual.html#pdf-os.date) function).

This is the local time.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.utctime

**syntax:** *str = ngx.utctime()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the current time stamp (in the format `yyyy-mm-dd hh:mm:ss`) of the nginx cached time (no syscall involved unlike Lua's [os.date](http://www.lua.org/manual/5.1/manual.html#pdf-os.date) function).

This is the UTC time.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.cookie_time

**syntax:** *str = ngx.cookie_time(sec)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns a formatted string can be used as the cookie expiration time. The parameter `sec` is the time stamp in seconds (like those returned from [ngx.time](https://github.com/openresty/lua-nginx-module#ngxtime)).

返回适合于 cookie 的时间。

```
 ngx.say(ngx.cookie_time(1290079655))
     -- yields "Thu, 18-Nov-10 11:27:35 GMT"
```

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.http_time

**syntax:** *str = ngx.http_time(sec)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns a formated string can be used as the http header time (for example, being used in `Last-Modified` header). The parameter `sec` is the time stamp in seconds (like those returned from [ngx.time](https://github.com/openresty/lua-nginx-module#ngxtime)).

返回一个可以作为 http  头的时间。

```
 ngx.say(ngx.http_time(1290079655))
     -- yields "Thu, 18 Nov 2010 11:27:35 GMT"
```

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.parse_http_time

**syntax:** *sec = ngx.parse_http_time(str)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Parse the http time string (as returned by [ngx.http_time](https://github.com/openresty/lua-nginx-module#ngxhttp_time)) into seconds. Returns the seconds or `nil` if the input string is in bad forms.

将 http time 的字符串解析为时间。

```
 local time = ngx.parse_http_time("Thu, 18 Nov 2010 11:27:35 GMT")
 if time == nil then
     ...
 end
```

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.is_subrequest

**syntax:** *value = ngx.is_subrequest*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua**

Returns `true` if the current request is an nginx subrequest, or `false` otherwise.

判断是否为 nginx 的 子请求。

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.re.match

**syntax:** *captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Matches the `subject` string using the Perl compatible regular expression `regex` with the optional `options`.

Only the first occurrence of the match is returned, or `nil` if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, `nil` and a string describing the error will be returned.

返回第一次匹配的内容。

When a match is found, a Lua table `captures` is returned, where `captures[0]` holds the whole substring being matched, and `captures[1]` holds the first parenthesized sub-pattern's capturing, `captures[2]` the second, and so on.

匹配的结果会有子匹配。

```
 local m, err = ngx.re.match("hello, 1234", "[0-9]+")
 if m then
     -- m[0] == "1234"

 else
     if err then
         ngx.log(ngx.ERR, "error: ", err)
         return
     end

     ngx.say("match not found")
 end
```

```
 local m, err = ngx.re.match("hello, 1234", "([0-9])[0-9]+")
 -- m[0] == "1234"
 -- m[1] == "1"
```

Named captures are also supported since the `v0.7.14` releaseand are returned in the same Lua table as key-value pairs as the numbered captures.

```
 local m, err = ngx.re.match("hello, 1234", "([0-9])(?<remaining>[0-9]+)")
 -- m[0] == "1234"
 -- m[1] == "1"
 -- m[2] == "234"
 -- m["remaining"] == "234"
```

Unmatched subpatterns will have `false` values in their `captures` table fields.

没有匹配到的子模式，其值为 false。

```
 local m, err = ngx.re.match("hello, world", "(world)|(hello)|(?<named>howdy)")
 -- m[0] == "hello"
 -- m[1] == false
 -- m[2] == "hello"
 -- m[3] == false
 -- m["named"] == false
```

Specify `options` to control how the match operation will be performed. The following option characters are supported:

```
a             anchored mode (only match from the beginning)

d             enable the DFA mode (or the longest token match semantics).
              this requires PCRE 6.0+ or else a Lua exception will be thrown.
              first introduced in ngx_lua v0.3.1rc30.

D             enable duplicate named pattern support. This allows named
              subpattern names to be repeated, returning the captures in
              an array-like Lua table. for example,
                local m = ngx.re.match("hello, world",
                                       "(?<named>\w+), (?<named>\w+)",
                                       "D")
                -- m["named"] == {"hello", "world"}
              this option was first introduced in the v0.7.14 release.
              this option requires at least PCRE 8.12.

i             case insensitive mode (similar to Perl's /i modifier)

j             enable PCRE JIT compilation, this requires PCRE 8.21+ which
              must be built with the --enable-jit option. for optimum performance,
              this option should always be used together with the 'o' option.
              first introduced in ngx_lua v0.3.1rc30.

J             enable the PCRE Javascript compatible mode. this option was
              first introduced in the v0.7.14 release. this option requires
              at least PCRE 8.12.

m             multi-line mode (similar to Perl's /m modifier)

o             compile-once mode (similar to Perl's /o modifier),
              to enable the worker-process-level compiled-regex cache

s             single-line mode (similar to Perl's /s modifier)

u             UTF-8 mode. this requires PCRE to be built with
              the --enable-utf8 option or else a Lua exception will be thrown.

U             similar to "u" but disables PCRE's UTF-8 validity check on
              the subject string. first introduced in ngx_lua v0.8.1.

x             extended mode (similar to Perl's /x modifier)

```

These options can be combined:

```
 local m, err = ngx.re.match("hello, world", "HEL LO", "ix")
 -- m[0] == "hello"
```

```
 local m, err = ngx.re.match("hello, 美好生活", "HELLO, (.{2})", "iu")
 -- m[0] == "hello, 美好"
 -- m[1] == "美好"
```

The `o` option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the [lua_regex_cache_max_entries](https://github.com/openresty/lua-nginx-module#lua_regex_cache_max_entries) directive.

每个 worker 缓存。

The optional fourth argument, `ctx`, can be a Lua table holding an optional `pos` field. When the `pos` field in the `ctx` table argument is specified, `ngx.re.match` will start matching from that offset (starting from 1). Regardless of the presence of the `pos` field in the `ctx` table, `ngx.re.match` will always set this `pos` field to the position *after* the substring matched by the whole pattern in case of a successful match. When match fails, the `ctx` table will be left intact.

ctx 中的 pos 可以用来指定匹配的开始位置。 没有指定 pos 时，会记录匹配之后的位置。

```
 local ctx = {}
 local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
      -- m[0] = "1234"
      -- ctx.pos == 5
```

```
 local ctx = { pos = 2 }
 local m, err = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
      -- m[0] = "234"
      -- ctx.pos == 5
```

The `ctx` table argument combined with the `a` regex modifier can be used to construct a lexer atop `ngx.re.match`.

Note that, the `options` argument is not optional when the `ctx` argument is specified and that the empty Lua string (`""`) must be used as placeholder for `options` if no meaningful regex options are required.

This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special Escaping Sequences](https://github.com/openresty/lua-nginx-module#special-escaping-sequences)).

To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the `--with-debug` option to Nginx or OpenResty's `./configure` script. Then, enable the "debug" error log level in `error_log` directive. The following message will be generated if PCRE JIT is enabled:

```
pcre JIT compiling result: 1

```

Starting from the `0.9.4` release, this function also accepts a 5th argument, `res_table`, for letting the caller supply the Lua table used to hold all the capturing results. Starting from `0.9.6`, it is the caller's responsibility to ensure this table is empty. This is very useful for recycling Lua tables and saving GC and table allocation overhead.

res_table 可以用来记录匹配的结果。

This feature was introduced in the `v0.2.1rc11` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.re.find

**syntax:** *from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch) but only returns the beginning index (`from`) and end index (`to`) of the matched substring. The returned indexes are 1-based and can be fed directly into the [string.sub](http://www.lua.org/manual/5.1/manual.html#pdf-string.sub) API function to obtain the matched substring.

与ngx.re.match 相似，但是返回匹配的索引位置。索引是基于1 开始的。可以直接使用 string.sub 来获得子串。

In case of errors (like bad regexes or any PCRE runtime errors), this API function returns two `nil` values followed by a string describing the error.

If no match is found, this function just returns a `nil` value.

Below is an example:

```
 local s = "hello, 1234"
 local from, to, err = ngx.re.find(s, "([0-9]+)", "jo")
 if from then
     ngx.say("from: ", from)
     ngx.say("to: ", to)
     ngx.say("matched: ", string.sub(s, from, to))
 else
     if err then
         ngx.say("error: ", err)
         return
     end
     ngx.say("not matched!")
 end
```

This example produces the output

```
from: 8
to: 11
matched: 1234

```

Because this API function does not create new Lua strings nor new Lua tables, it is much faster than [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch). It should be used wherever possible.

由于此 api 不产生新的 lua String或table ，因此比 ngx.re.match 更快速。

Since the `0.9.3` release, an optional 5th argument, `nth`, is supported to specify which (submatch) capture's indexes to return. When `nth` is 0 (which is the default), the indexes for the whole matched substring is returned; when `nth` is 1, then the 1st submatch capture's indexes are returned; when `nth` is 2, then the 2nd submatch capture is returned, and so on. When the specified submatch does not have a match, then two `nil` values will be returned. Below is an example for this:

```
 local str = "hello, 1234"
 local from, to = ngx.re.find(str, "([0-9])([0-9]+)", "jo", nil, 2)
 if from then
     ngx.say("matched 2nd submatch: ", string.sub(str, from, to))  -- yields "234"
 end
```

This API function was first introduced in the `v0.9.2` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.re.gmatch

**syntax:** *iterator, err = ngx.re.gmatch(subject, regex, options?)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch), but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the `<subject>` string argument with the PCRE `regex`.

返回一个迭代，可以迭代要匹配的串。

In case of errors, like seeing an ill-formed regular expression, `nil` and a string describing the error will be returned.

Here is a small example to demonstrate its basic usage:

```
 local iterator, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
 if not iterator then
     ngx.log(ngx.ERR, "error: ", err)
     return
 end

 local m
 m, err = iterator()    -- m[0] == m[1] == "hello"
 if err then
     ngx.log(ngx.ERR, "error: ", err)
     return
 end

 m, err = iterator()    -- m[0] == m[1] == "world"
 if err then
     ngx.log(ngx.ERR, "error: ", err)
     return
 end

 m, err = iterator()    -- m == nil
 if err then
     ngx.log(ngx.ERR, "error: ", err)
     return
 end
```

More often we just put it into a Lua loop:

```
 local it, err = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
 if not it then
     ngx.log(ngx.ERR, "error: ", err)
     return
 end

 while true do
     local m, err = it()
     if err then
         ngx.log(ngx.ERR, "error: ", err)
         return
     end

     if not m then
         -- no match found (any more)
         break
     end

     -- found a match
     ngx.say(m[0])
     ngx.say(m[1])
 end
```

The optional `options` argument takes exactly the same semantics as the [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch) method.

The current implementation requires that the iterator returned should only be used in a single request. That is, one should *not* assign it to a variable belonging to persistent namespace like a Lua package.

当前的实现只能用于单个请求，因此，不能将其Lua 的全局变量。

This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special Escaping Sequences](https://github.com/openresty/lua-nginx-module#special-escaping-sequences)).

This feature was first introduced in the `v0.2.1rc12` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.re.sub

**syntax:** *newstr, n, err = ngx.re.sub(subject, regex, replace, options?)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Substitutes the first match of the Perl compatible regular expression `regex` on the `subject` argument string with the string or function argument `replace`. The optional `options` argument has exactly the same meaning as in [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch).

将与正则相匹配的使用其他字符串进行替换。

This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the `<replace>` string argument, it will return `nil` and a string describing the error.

When the `replace` is a string, then it is treated as a special template for string replacement. For example,

```
 local newstr, n, err = ngx.re.sub("hello, 1234", "([0-9])[0-9]", "[$0][$1]")
 if newstr then
     -- newstr == "hello, [12][1]34"
     -- n == 1
 else
     ngx.log(ngx.ERR, "error: ", err)
     return
 end
```

where `$0` referring to the whole substring matched by the pattern and `$1` referring to the first parenthesized capturing substring.

Curly braces can also be used to disambiguate variable names from the background string literals:

```
 local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "${0}00")
     -- newstr == "hello, 100234"
     -- n == 1
```

Literal dollar sign characters (`$`) in the `replace` string argument can be escaped by another dollar sign, for instance,

对 $ 进行转义时，使用 $$

```
 local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "$$")
     -- newstr == "hello, $234"
     -- n == 1
```

Do not use backlashes to escape dollar signs; it will not work as expected.

When the `replace` argument is of type "function", then it will be invoked with the "match table" as the argument to generate the replace string literal for substitution. The "match table" fed into the `replace` function is exactly the same as the return value of [ngx.re.match](https://github.com/openresty/lua-nginx-module#ngxrematch). Here is an example:

替换也可以是一个函数。

```
 local func = function (m)
     return "[" .. m[0] .. "][" .. m[1] .. "]"
 end
 local newstr, n, err = ngx.re.sub("hello, 1234", "( [0-9] ) [0-9]", func, "x")
     -- newstr == "hello, [12][1]34"
     -- n == 1
```

The dollar sign characters in the return value of the `replace` function argument are not special at all.

This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special Escaping Sequences](https://github.com/openresty/lua-nginx-module#special-escaping-sequences)).

This feature was first introduced in the `v0.2.1rc13` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.re.gsub

**syntax:** *newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Just like [ngx.re.sub](https://github.com/openresty/lua-nginx-module#ngxresub), but does global substitution.

做全局替换。

Here is some examples:

```
 local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]", "i")
 if newstr then
     -- newstr == "[hello,h], [world,w]"
     -- n == 2
 else
     ngx.log(ngx.ERR, "error: ", err)
     return
 end
```

```
 local func = function (m)
     return "[" .. m[0] .. "," .. m[1] .. "]"
 end
 local newstr, n, err = ngx.re.gsub("hello, world", "([a-z])[a-z]+", func, "i")
     -- newstr == "[hello,h], [world,w]"
     -- n == 2
```

This method requires the PCRE library enabled in Nginx.  ([Known Issue With Special Escaping Sequences](https://github.com/openresty/lua-nginx-module#special-escaping-sequences)).

This feature was first introduced in the `v0.2.1rc15` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT

**syntax:** *dict = ngx.shared.DICT*

**syntax:** *dict = ngx.shared[name_var]*

**context:** *init_by_lua\*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Fetching the shm-based Lua dictionary object for the shared memory zone named `DICT` defined by the [lua_shared_dict](https://github.com/openresty/lua-nginx-module#lua_shared_dict) directive.

Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.

获得共享的区域。

The resulting object `dict` has the following methods:

- [get](https://github.com/openresty/lua-nginx-module#ngxshareddictget)
- [get_stale](https://github.com/openresty/lua-nginx-module#ngxshareddictget_stale)
- [set](https://github.com/openresty/lua-nginx-module#ngxshareddictset)
- [safe_set](https://github.com/openresty/lua-nginx-module#ngxshareddictsafe_set)
- [add](https://github.com/openresty/lua-nginx-module#ngxshareddictadd)
- [safe_add](https://github.com/openresty/lua-nginx-module#ngxshareddictsafe_add)
- [replace](https://github.com/openresty/lua-nginx-module#ngxshareddictreplace)
- [delete](https://github.com/openresty/lua-nginx-module#ngxshareddictdelete)
- [incr](https://github.com/openresty/lua-nginx-module#ngxshareddictincr)
- [lpush](https://github.com/openresty/lua-nginx-module#ngxshareddictlpush)
- [rpush](https://github.com/openresty/lua-nginx-module#ngxshareddictrpush)
- [lpop](https://github.com/openresty/lua-nginx-module#ngxshareddictlpop)
- [rpop](https://github.com/openresty/lua-nginx-module#ngxshareddictrpop)
- [llen](https://github.com/openresty/lua-nginx-module#ngxshareddictllen)
- [flush_all](https://github.com/openresty/lua-nginx-module#ngxshareddictflush_all)
- [flush_expired](https://github.com/openresty/lua-nginx-module#ngxshareddictflush_expired)
- [get_keys](https://github.com/openresty/lua-nginx-module#ngxshareddictget_keys)

All these methods are *atomic* operations, that is, safe from concurrent accesses from multiple nginx worker processes for the same `lua_shared_dict` zone.

这些方法都是原子操作。

Here is an example:

```
 http {
     lua_shared_dict dogs 10m;
     server {
         location /set {
             content_by_lua_block {
                 local dogs = ngx.shared.dogs
                 dogs:set("Jim", 8)
                 ngx.say("STORED")
             }
         }
         location /get {
             content_by_lua_block {
                 local dogs = ngx.shared.dogs
                 ngx.say(dogs:get("Jim"))
             }
         }
     }
 }
```

Let us test it:

```
 $ curl localhost/set
 STORED

 $ curl localhost/get
 8

 $ curl localhost/get
 8
```

The number `8` will be consistently output when accessing `/get` regardless of how many Nginx workers there are because the `dogs` dictionary resides in the shared memory and visible to *all* of the worker processes.

The shared dictionary will retain its contents through a server config reload (either by sending the `HUP` signal to the Nginx process or by using the `-s reload` command-line option).

The contents in the dictionary storage will be lost, however, when the Nginx server quits.

This feature was first introduced in the `v0.3.1rc22` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.get

**syntax:** *value, flags = ngx.shared.DICT:get(key)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Retrieving the value in the dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict) for the key `key`. If the key does not exist or has expired, then `nil` will be returned.

获取 ngx.shared.DICT 中 key对应的值。

In case of errors, `nil` and a string describing the error will be returned.

The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.

获得的类型与插入时的类型一致。

The first argument to this method must be the dictionary object itself, for example,

```
 local cats = ngx.shared.cats
 local value, flags = cats.get(cats, "Marry")
```

or use Lua's syntactic sugar for method calls:

```
 local cats = ngx.shared.cats
 local value, flags = cats:get("Marry")
```

These two forms are fundamentally equivalent.

If the user flags is `0` (the default), then no flags value will be returned.

This feature was first introduced in the `v0.3.1rc22` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.get_stale

**syntax:** *value, flags, stale = ngx.shared.DICT:get_stale(key)*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to the [get](https://github.com/openresty/lua-nginx-module#ngxshareddictget) method but returns the value even if the key has already expired.

即使超时也返回。（stale 指示是否超时）

Returns a 3rd value, `stale`, indicating whether the key has expired or not.

Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.

This method was first introduced in the `0.8.6` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.set

**syntax:** *success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Unconditionally sets a key-value pair into the shm-based dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict). Returns three values:

- `success`: boolean value to indicate whether the key-value pair is stored or not.
- `err`: textual error message, can be `"no memory"`.
- `forcible`: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.

The `value` argument inserted can be Lua booleans, numbers, strings, or `nil`. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [get](https://github.com/openresty/lua-nginx-module#ngxshareddictget) method.

The optional `exptime` argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is `0.001` seconds. If the `exptime` takes the value `0` (which is the default), then the item will never expire.

The optional `flags` argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to `0`. The user flags argument was first introduced in the `v0.5.0rc2` release.

When it fails to allocate memory for the current key-value item, then `set` will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [lua_shared_dict](https://github.com/openresty/lua-nginx-module#lua_shared_dict) or memory segmentation), then the `err` return value will be `no memory` and `success` will be `false`.

If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the `forcible` return value will be `true`. If it stores the item without forcibly removing other valid items, then the return value `forcible` will be `false`.

The first argument to this method must be the dictionary object itself, for example,

```
 local cats = ngx.shared.cats
 local succ, err, forcible = cats.set(cats, "Marry", "it is a nice cat!")
```

or use Lua's syntactic sugar for method calls:

```
 local cats = ngx.shared.cats
 local succ, err, forcible = cats:set("Marry", "it is a nice cat!")
```

These two forms are fundamentally equivalent.

This feature was first introduced in the `v0.3.1rc22` release.

Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.safe_set

**syntax:** *ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to the [set](https://github.com/openresty/lua-nginx-module#ngxshareddictset) method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return `nil` and the string "no memory".

This feature was first introduced in the `v0.7.18` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.add

**syntax:** *success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Just like the [set](https://github.com/openresty/lua-nginx-module#ngxshareddictset) method, but only stores the key-value pair into the dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict) if the key does *not* exist.

If the `key` argument already exists in the dictionary (and not expired for sure), the `success` return value will be `false` and the `err` return value will be `"exists"`.

This feature was first introduced in the `v0.3.1rc22` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.safe_add

**syntax:** *ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to the [add](https://github.com/openresty/lua-nginx-module#ngxshareddictadd) method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return `nil` and the string "no memory".

This feature was first introduced in the `v0.7.18` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.replace

**syntax:** *success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Just like the [set](https://github.com/openresty/lua-nginx-module#ngxshareddictset) method, but only stores the key-value pair into the dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict) if the key *does* exist.

If the `key` argument does *not* exist in the dictionary (or expired already), the `success` return value will be `false` and the `err` return value will be `"not found"`.

This feature was first introduced in the `v0.3.1rc22` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.delete

**syntax:** *ngx.shared.DICT:delete(key)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Unconditionally removes the key-value pair from the shm-based dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

It is equivalent to `ngx.shared.DICT:set(key, nil)`.

This feature was first introduced in the `v0.3.1rc22` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.incr

**syntax:** *newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Increments the (numerical) value for `key` in the shm-based dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict) by the step value `value`. Returns the new resulting number if the operation is successfully completed or `nil` and an error message otherwise.

When the key does not exist or has already expired in the shared dictionary,

1. if the `init` argument is not specified or takes the value `nil`, this method will return `nil` and the error string `"not found"`, or
2. if the `init` argument takes a number value, this method will create a new `key` with the value `init + value`.

Like the [add](https://github.com/openresty/lua-nginx-module#ngxshareddictadd) method, it also overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone.

The `forcible` return value will always be `nil` when the `init` argument is not specified.

If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the `forcible` return value will be `true`. If it stores the item without forcibly removing other valid items, then the return value `forcible` will be `false`.

If the original value is not a valid Lua number in the dictionary, it will return `nil` and `"not a number"`.

The `value` argument and `init` argument can be any valid Lua numbers, like negative numbers or floating-point numbers.

This method was first introduced in the `v0.3.1rc22` release.

The optional `init` parameter was first added in the `v0.10.6` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.lpush

**syntax:** *length, err = ngx.shared.DICT:lpush(key, value)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Inserts the specified (numerical or string) `value` at the head of the list named `key` in the shm-based dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict). Returns the number of elements in the list after the push operation.

If `key` does not exist, it is created as an empty list before performing the push operation. When the `key` already takes a value that is not a list, it will return `nil` and `"value not a list"`.

It never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return `nil` and the string "no memory".

This feature was first introduced in the `v0.10.6` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.rpush

**syntax:** *length, err = ngx.shared.DICT:rpush(key, value)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to the [lpush](https://github.com/openresty/lua-nginx-module#ngxshareddictlpush) method, but inserts the specified (numerical or string) `value` at the tail of the list named `key`.

This feature was first introduced in the `v0.10.6` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.lpop

**syntax:** *val, err = ngx.shared.DICT:lpop(key)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Removes and returns the first element of the list named `key` in the shm-based dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

If `key` does not exist, it will return `nil`. When the `key` already takes a value that is not a list, it will return `nil` and `"value not a list"`.

This feature was first introduced in the `v0.10.6` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.rpop

**syntax:** *val, err = ngx.shared.DICT:rpop(key)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Removes and returns the last element of the list named `key` in the shm-based dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

If `key` does not exist, it will return `nil`. When the `key` already takes a value that is not a list, it will return `nil` and `"value not a list"`.

This feature was first introduced in the `v0.10.6` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.llen

**syntax:** *len, err = ngx.shared.DICT:llen(key)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the number of elements in the list named `key` in the shm-based dictionary [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

If key does not exist, it is interpreted as an empty list and 0 is returned. When the `key` already takes a value that is not a list, it will return `nil` and `"value not a list"`.

This feature was first introduced in the `v0.10.6` release.

See also [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.flush_all

**syntax:** *ngx.shared.DICT:flush_all()*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.

This feature was first introduced in the `v0.5.0rc17` release.

See also [ngx.shared.DICT.flush_expired](https://github.com/openresty/lua-nginx-module#ngxshareddictflush_expired) and [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.flush_expired

**syntax:** *flushed = ngx.shared.DICT:flush_expired(max_count?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Flushes out the expired items in the dictionary, up to the maximal number specified by the optional `max_count` argument. When the `max_count` argument is given `0` or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.

Unlike the [flush_all](https://github.com/openresty/lua-nginx-module#ngxshareddictflush_all) method, this method actually free up the memory used by the expired items.

This feature was first introduced in the `v0.6.3` release.

See also [ngx.shared.DICT.flush_all](https://github.com/openresty/lua-nginx-module#ngxshareddictflush_all) and [ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.shared.DICT.get_keys

**syntax:** *keys = ngx.shared.DICT:get_keys(max_count?)*

**context:** *init_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Fetch a list of the keys from the dictionary, up to `<max_count>`.

By default, only the first 1024 keys (if any) are returned. When the `<max_count>` argument is given the value `0`, then all the keys will be returned even there is more than 1024 keys in the dictionary.

**CAUTION** Avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block Nginx worker processes trying to access the dictionary.

This feature was first introduced in the `v0.7.3` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.socket.udp

**syntax:** *udpsock = ngx.socket.udp()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:

- [setpeername](https://github.com/openresty/lua-nginx-module#udpsocksetpeername)
- [send](https://github.com/openresty/lua-nginx-module#udpsocksend)
- [receive](https://github.com/openresty/lua-nginx-module#udpsockreceive)
- [close](https://github.com/openresty/lua-nginx-module#udpsockclose)
- [settimeout](https://github.com/openresty/lua-nginx-module#udpsocksettimeout)

It is intended to be compatible with the UDP API of the [LuaSocket](http://w3.impa.br/%7Ediego/software/luasocket/udp.html) library but is 100% nonblocking out of the box.

This feature was first introduced in the `v0.5.7` release.

See also [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## udpsock:setpeername

**syntax:** *ok, err = udpsock:setpeername(host, port)*

**syntax:** *ok, err = udpsock:setpeername("unix:/path/to/unix-domain.socket")*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a "connection", but only just set the name of the remote peer for subsequent read/write operations.

Both IP addresses and domain names can be specified as the `host` argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the [resolver](http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver) directive in the `nginx.conf` file like this:

```
 resolver 8.8.8.8;  # use Google's public DNS nameserver
```

If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.

In case of error, the method returns `nil` followed by a string describing the error. In case of success, the method returns `1`.

Here is an example for connecting to a UDP (memcached) server:

```
 location /test {
     resolver 8.8.8.8;

     content_by_lua_block {
         local sock = ngx.socket.udp()
         local ok, err = sock:setpeername("my.memcached.server.domain", 11211)
         if not ok then
             ngx.say("failed to connect to memcached: ", err)
             return
         end
         ngx.say("successfully connected to memcached!")
         sock:close()
     }
 }
```

Since the `v0.7.18` release, connecting to a datagram unix domain socket file is also possible on Linux:

```
 local sock = ngx.socket.udp()
 local ok, err = sock:setpeername("unix:/tmp/some-datagram-service.sock")
 if not ok then
     ngx.say("failed to connect to the datagram unix domain socket: ", err)
     return
 end
```

assuming the datagram service is listening on the unix domain socket file `/tmp/some-datagram-service.sock` and the client socket will use the "autobind" feature on Linux.

Calling this method on an already connected socket object will cause the original connection to be closed first.

This method was first introduced in the `v0.5.7` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## udpsock:send

**syntax:** *ok, err = udpsock:send(data)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Sends data on the current UDP or datagram unix domain socket object.

In case of success, it returns `1`. Otherwise, it returns `nil` and a string describing the error.

The input argument `data` can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.

This feature was first introduced in the `v0.5.7` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## udpsock:receive

**syntax:** *data, err = udpsock:receive(size?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, `size`.

This method is a synchronous operation and is 100% nonblocking.

In case of success, it returns the data received; in case of error, it returns `nil` with a string describing the error.

If the `size` argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than `8192`, then `8192` will be used instead.

If no argument is specified, then the maximal buffer size, `8192` is assumed.

Timeout for the reading operation is controlled by the [lua_socket_read_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout) config directive and the [settimeout](https://github.com/openresty/lua-nginx-module#udpsocksettimeout) method. And the latter takes priority. For example:

```
 sock:settimeout(1000)  -- one second timeout
 local data, err = sock:receive()
 if not data then
     ngx.say("failed to read a packet: ", err)
     return
 end
 ngx.say("successfully read a packet: ", data)
```

It is important here to call the [settimeout](https://github.com/openresty/lua-nginx-module#udpsocksettimeout) method *before* calling this method.

This feature was first introduced in the `v0.5.7` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## udpsock:close

**syntax:** *ok, err = udpsock:close()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Closes the current UDP or datagram unix domain socket. It returns the `1` in case of success and returns `nil` with a string describing the error otherwise.

Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.

This feature was first introduced in the `v0.5.7` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## udpsock:settimeout

**syntax:** *udpsock:settimeout(time)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Set the timeout value in milliseconds for subsequent socket operations (like [receive](https://github.com/openresty/lua-nginx-module#udpsockreceive)).

Settings done by this method takes priority over those config directives, like [lua_socket_read_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout).

This feature was first introduced in the `v0.5.7` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.socket.stream

Just an alias to [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp). If the stream-typed cosocket may also connect to a unix domainsocket, then this API name is preferred.

This API function was first added to the `v0.10.1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.socket.tcp

**syntax:** *tcpsock = ngx.socket.tcp()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the "cosocket" objects). The following methods are supported on this object:

- [connect](https://github.com/openresty/lua-nginx-module#tcpsockconnect)
- [sslhandshake](https://github.com/openresty/lua-nginx-module#tcpsocksslhandshake)
- [send](https://github.com/openresty/lua-nginx-module#tcpsocksend)
- [receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive)
- [close](https://github.com/openresty/lua-nginx-module#tcpsockclose)
- [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout)
- [settimeouts](https://github.com/openresty/lua-nginx-module#tcpsocksettimeouts)
- [setoption](https://github.com/openresty/lua-nginx-module#tcpsocksetoption)
- [receiveuntil](https://github.com/openresty/lua-nginx-module#tcpsockreceiveuntil)
- [setkeepalive](https://github.com/openresty/lua-nginx-module#tcpsocksetkeepalive)
- [getreusedtimes](https://github.com/openresty/lua-nginx-module#tcpsockgetreusedtimes)

It is intended to be compatible with the TCP API of the [LuaSocket](http://w3.impa.br/%7Ediego/software/luasocket/tcp.html) library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.

The cosocket object created by this API function has exactly the same lifetime as the Lua handler creating it. So never pass the cosocket object to any other Lua handler (including ngx.timer callback functions) and never share the cosocket object between different NGINX requests.

For every cosocket object's underlying connection, if you do notexplicitly close it (via [close](https://github.com/openresty/lua-nginx-module#tcpsockclose)) or put it back to the connectionpool (via [setkeepalive](https://github.com/openresty/lua-nginx-module#tcpsocksetkeepalive)), then it is automatically closed when one ofthe following two events happens:

- the current request handler completes, or
- the Lua cosocket object value gets collected by the Lua GC.

Fatal errors in cosocket operations always automatically close the currentconnection (note that, read timeout error is the only error that isnot fatal), and if you call [close](https://github.com/openresty/lua-nginx-module#tcpsockclose) on a closed connection, you will getthe "closed" error.

Starting from the `0.9.9` release, the cosocket object here is full-duplex, that is, a reader "light thread" and a writer "light thread" can operate on a single cosocket object simultaneously (both "light threads" must belong to the same Lua handler though, see reasons above). But you cannot have two "light threads" both reading (or writing or connecting) the same cosocket, otherwise you might get an error like "socket busy reading" when calling the methods of the cosocket object.

This feature was first introduced in the `v0.5.0rc1` release.

See also [ngx.socket.udp](https://github.com/openresty/lua-nginx-module#ngxsocketudp).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:connect

**syntax:** *ok, err = tcpsock:connect(host, port, options_table?)*

**syntax:** *ok, err = tcpsock:connect("unix:/path/to/unix-domain.socket", options_table?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.

Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [ngx.socket.connect](https://github.com/openresty/lua-nginx-module#ngxsocketconnect) function).

Both IP addresses and domain names can be specified as the `host` argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the [resolver](http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver) directive in the `nginx.conf` file like this:

```
 resolver 8.8.8.8;  # use Google's public DNS nameserver
```

If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.

In case of error, the method returns `nil` followed by a string describing the error. In case of success, the method returns `1`.

Here is an example for connecting to a TCP server:

```
 location /test {
     resolver 8.8.8.8;

     content_by_lua_block {
         local sock = ngx.socket.tcp()
         local ok, err = sock:connect("www.google.com", 80)
         if not ok then
             ngx.say("failed to connect to google: ", err)
             return
         end
         ngx.say("successfully connected to google!")
         sock:close()
     }
 }
```

Connecting to a Unix Domain Socket file is also possible:

```
 local sock = ngx.socket.tcp()
 local ok, err = sock:connect("unix:/tmp/memcached.sock")
 if not ok then
     ngx.say("failed to connect to the memcached unix domain socket: ", err)
     return
 end
```

assuming memcached (or something else) is listening on the unix domain socket file `/tmp/memcached.sock`.

Timeout for the connecting operation is controlled by the [lua_socket_connect_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_connect_timeout) config directive and the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method. And the latter takes priority. For example:

```
 local sock = ngx.socket.tcp()
 sock:settimeout(1000)  -- one second timeout
 local ok, err = sock:connect(host, port)
```

It is important here to call the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method *before* calling this method.

Calling this method on an already connected socket object will cause the original connection to be closed first.

An optional Lua table can be specified as the last argument to this method to specify various connect options:

- `pool`specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template `"<host>:<port>"` or `"<unix-socket-path>"`.

The support for the options table argument was first introduced in the `v0.5.7` release.

This method was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:sslhandshake

**syntax:** *session, err = tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?, send_status_req?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Does SSL/TLS handshake on the currently established connection.

The optional `reused_session` argument can take a former SSLsession userdata returned by a previous `sslhandshake`call for exactly the same target. For short-lived connections, reusing SSLsessions can usually speed up the handshake by one order by magnitude but itis not so useful if the connection pool is enabled. This argument defaults to`nil`. If this argument takes the boolean `false` value, no SSL sessionuserdata would return by this call and only a Lua boolean will be returned asthe first return value; otherwise the current SSL session willalways be returned as the first argument in case of successes.

The optional `server_name` argument is used to specify the servername for the new TLS extension Server Name Indication (SNI). Use of SNI canmake different servers share the same IP address on the server side. Also,when SSL verification is enabled, this `server_name` argument isalso used to validate the server name specified in the server certificate sent fromthe remote.

The optional `ssl_verify` argument takes a Lua boolean value tocontrol whether to perform SSL verification. When set to `true`, the servercertificate will be verified according to the CA certificates specified bythe [lua_ssl_trusted_certificate](https://github.com/openresty/lua-nginx-module#lua_ssl_trusted_certificate) directive.You may also need to adjust the [lua_ssl_verify_depth](https://github.com/openresty/lua-nginx-module#lua_ssl_verify_depth)directive to control how deep we should follow along the certificate chain.Also, when the `ssl_verify` argument is true and the`server_name` argument is also specified, the latter will be usedto validate the server name in the server certificate.

The optional `send_status_req` argument takes a boolean that controls whether to sendthe OCSP status request in the SSL handshake request (which is for requesting OCSP stapling).

For connections that have already done SSL/TLS handshake, this method returnsimmediately.

This method was first introduced in the `v0.9.11` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:send

**syntax:** *bytes, err = tcpsock:send(data)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Sends data without blocking on the current TCP or Unix Domain Socket connection.

This method is a synchronous operation that will not return until *all* the data has been flushed into the system socket send buffer or an error occurs.

In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns `nil` and a string describing the error.

The input argument `data` can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.

Timeout for the sending operation is controlled by the [lua_socket_send_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_send_timeout) config directive and the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method. And the latter takes priority. For example:

```
 sock:settimeout(1000)  -- one second timeout
 local bytes, err = sock:send(request)
```

It is important here to call the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method *before* calling this method.

In case of any connection errors, this method always automatically closes the current connection.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:receive

**syntax:** *data, err, partial = tcpsock:receive(size)*

**syntax:** *data, err, partial = tcpsock:receive(pattern?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Receives data from the connected socket according to the reading pattern or size.

This method is a synchronous operation just like the [send](https://github.com/openresty/lua-nginx-module#tcpsocksend) method and is 100% nonblocking.

In case of success, it returns the data received; in case of error, it returns `nil` with a string describing the error and the partial data received so far.

If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.

If a non-number-like string argument is specified, then it is interpreted as a "pattern". The following patterns are supported:

- `'*a'`: reads from the socket until the connection is closed. No end-of-line translation is performed;
- `'*l'`: reads a line of text from the socket. The line is terminated by a `Line Feed` (LF) character (ASCII 10), optionally preceded by a `Carriage Return` (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.

If no argument is specified, then it is assumed to be the pattern `'*l'`, that is, the line reading pattern.

Timeout for the reading operation is controlled by the [lua_socket_read_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout) config directive and the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method. And the latter takes priority. For example:

```
 sock:settimeout(1000)  -- one second timeout
 local line, err, partial = sock:receive()
 if not line then
     ngx.say("failed to read a line: ", err)
     return
 end
 ngx.say("successfully read a line: ", line)
```

It is important here to call the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method *before* calling this method.

Since the `v0.8.8` release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:receiveuntil

**syntax:** *iterator = tcpsock:receiveuntil(pattern, options?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.

Here is an example for using this method to read a data stream with the boundary sequence `--abcedhb`:

```
 local reader = sock:receiveuntil("\r\n--abcedhb")
 local data, err, partial = reader()
 if not data then
     ngx.say("failed to read the data stream: ", err)
 end
 ngx.say("read the data stream: ", data)
```

When called without any argument, the iterator function returns the received data right *before* the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is `'hello, world! -agentzh\r\n--abcedhb blah blah'`, then the string `'hello, world! -agentzh'` will be returned.

In case of error, the iterator function will return `nil` along with a string describing the error and the partial data bytes that have been read so far.

The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.

The iterator function behaves differently (i.e., like a real iterator) when it is called with a `size` argument. That is, it will read that `size` of data on each invocation and will return `nil` at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the `err` return value will be `nil` too. The iterator function will be reset after the last successful invocation that returns `nil` data and `nil` error. Consider the following example:

```
 local reader = sock:receiveuntil("\r\n--abcedhb")

 while true do
     local data, err, partial = reader(4)
     if not data then
         if err then
             ngx.say("failed to read the data stream: ", err)
             break
         end

         ngx.say("read done")
         break
     end
     ngx.say("read chunk: [", data, "]")
 end
```

Then for the incoming data stream `'hello, world! -agentzh\r\n--abcedhb blah blah'`, we shall get the following output from the sample code above:

```
read chunk: [hell]
read chunk: [o, w]
read chunk: [orld]
read chunk: [! -a]
read chunk: [gent]
read chunk: [zh]
read done

```

Note that, the actual data returned *might* be a little longer than the size limit specified by the `size` argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.

Timeout for the iterator function's reading operation is controlled by the [lua_socket_read_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout) config directive and the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method. And the latter takes priority. For example:

```
 local readline = sock:receiveuntil("\r\n")

 sock:settimeout(1000)  -- one second timeout
 line, err, partial = readline()
 if not line then
     ngx.say("failed to read a line: ", err)
     return
 end
 ngx.say("successfully read a line: ", line)
```

It is important here to call the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method *before* calling the iterator function (note that the `receiveuntil` call is irrelevant here).

As from the `v0.5.1` release, this method also takes an optional `options` table argument to control the behavior. The following options are supported:

- `inclusive`

The `inclusive` takes a boolean value to control whether to include the pattern string in the returned data string. Default to `false`. For example,

```
 local reader = tcpsock:receiveuntil("_END_", { inclusive = true })
 local data = reader()
 ngx.say(data)
```

Then for the input data stream `"hello world _END_ blah blah blah"`, then the example above will output `hello world _END_`, including the pattern string `_END_` itself.

Since the `v0.8.8` release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.

This method was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:close

**syntax:** *ok, err = tcpsock:close()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Closes the current TCP or stream unix domain socket. It returns the `1` in case of success and returns `nil` with a string describing the error otherwise.

Note that there is no need to call this method on socket objects that have invoked the [setkeepalive](https://github.com/openresty/lua-nginx-module#tcpsocksetkeepalive) method because the socket object is already closed (and the current connection is saved into the built-in connection pool).

Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:settimeout

**syntax:** *tcpsock:settimeout(time)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Set the timeout value in milliseconds for subsequent socket operations ([connect](https://github.com/openresty/lua-nginx-module#tcpsockconnect), [receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive), and iterators returned from [receiveuntil](https://github.com/openresty/lua-nginx-module#tcpsockreceiveuntil)).

Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_connect_timeout), [lua_socket_send_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_send_timeout), and [lua_socket_read_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout).

Note that this method does *not* affect the [lua_socket_keepalive_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_keepalive_timeout) setting; the `timeout` argument to the [setkeepalive](https://github.com/openresty/lua-nginx-module#tcpsocksetkeepalive) method should be used for this purpose instead.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:settimeouts

**syntax:** *tcpsock:settimeouts(connect_timeout, send_timeout, read_timeout)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Sets the connect timeout thresold, send timeout threshold, and read timeout threshold, respetively, in milliseconds, for subsequent socketoperations ([connect](https://github.com/openresty/lua-nginx-module#tcpsockconnect), [send](https://github.com/openresty/lua-nginx-module#tcpsocksend), [receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive), and iterators returned from [receiveuntil](https://github.com/openresty/lua-nginx-module#tcpsockreceiveuntil)).

Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_connect_timeout), [lua_socket_send_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_send_timeout), and [lua_socket_read_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout).

You are recommended to use [settimeouts](https://github.com/openresty/lua-nginx-module#tcpsocksettimeouts) instead of [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout).

Note that this method does *not* affect the [lua_socket_keepalive_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_keepalive_timeout) setting; the `timeout` argument to the [setkeepalive](https://github.com/openresty/lua-nginx-module#tcpsocksetkeepalive) method should be used for this purpose instead.

This feature was first introduced in the `v0.10.7` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:setoption

**syntax:** *tcpsock:setoption(option, value?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

This function is added for [LuaSocket](http://w3.impa.br/%7Ediego/software/luasocket/tcp.html) API compatibility and does nothing for now. Its functionality will be implemented in future.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:setkeepalive

**syntax:** *ok, err = tcpsock:setkeepalive(timeout?, size?)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Puts the current socket's connection immediately into the cosocket built-in connection pool and keep it alive until other [connect](https://github.com/openresty/lua-nginx-module#tcpsockconnect) method calls request it or the associated maximal idle timeout is expired.

The first optional argument, `timeout`, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the [lua_socket_keepalive_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_keepalive_timeout) config directive will be used. If the `0` value is given, then the timeout interval is unlimited.

The second optional argument, `size`, can be used to specify the maximal number of connections allowed in the connection pool for the current server (i.e., the current host-port pair or the unix domain socket file path). Note that the size of the connection pool cannot be changed once the pool is created. When this argument is omitted, the default setting in the [lua_socket_pool_size](https://github.com/openresty/lua-nginx-module#lua_socket_pool_size) config directive will be used.

When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.

Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.

Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.

In case of success, this method returns `1`; otherwise, it returns `nil` and a string describing the error.

When the system receive buffer for the current connection has unread data, then this method will return the "connection in dubious state" error message (as the second return value) because the previous session has unread data left behind for the next session and the connection is not safe to be reused.

This method also makes the current cosocket object enter the "closed" state, so there is no need to manually call the [close](https://github.com/openresty/lua-nginx-module#tcpsockclose) method on it afterwards.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## tcpsock:getreusedtimes

**syntax:** *count, err = tcpsock:getreusedtimes()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

This method returns the (successfully) reused times for the current connection. In case of error, it returns `nil` and a string describing the error.

If the current connection does not come from the built-in connection pool, then this method always returns `0`, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.socket.connect

**syntax:** *tcpsock, err = ngx.socket.connect(host, port)*

**syntax:** *tcpsock, err = ngx.socket.connect("unix:/path/to/unix-domain.socket")*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.**

This function is a shortcut for combining [ngx.socket.tcp()](https://github.com/openresty/lua-nginx-module#ngxsockettcp) and the [connect()](https://github.com/openresty/lua-nginx-module#tcpsockconnect) method call in a single operation. It is actually implemented like this:

```
 local sock = ngx.socket.tcp()
 local ok, err = sock:connect(...)
 if not ok then
     return nil, err
 end
 return sock
```

There is no way to use the [settimeout](https://github.com/openresty/lua-nginx-module#tcpsocksettimeout) method to specify connecting timeout for this method and the [lua_socket_connect_timeout](https://github.com/openresty/lua-nginx-module#lua_socket_connect_timeout) directive must be set at configure time instead.

This feature was first introduced in the `v0.5.0rc1` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.get_phase

**syntax:** *str = ngx.get_phase()*

**context:** *init_by_lua\*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Retrieves the current running phase name. Possible return values are

- `init`for the context of [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua).
- `init_worker`for the context of [init_worker_by_lua*](https://github.com/openresty/lua-nginx-module#init_worker_by_lua).
- `ssl_cert`for the context of [ssl_certificate_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block).
- `ssl_session_fetch`for the context of [ssl_session_fetch_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_session_fetch_by_lua_block).
- `ssl_session_store`for the context of [ssl_session_store_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_block).
- `set`for the context of [set_by_lua*](https://github.com/openresty/lua-nginx-module#set_by_lua).
- `rewrite`for the context of [rewrite_by_lua*](https://github.com/openresty/lua-nginx-module#rewrite_by_lua).
- `balancer`for the context of [balancer_by_lua*](https://github.com/openresty/lua-nginx-module#balancer_by_lua_block).
- `access`for the context of [access_by_lua*](https://github.com/openresty/lua-nginx-module#access_by_lua).
- `content`for the context of [content_by_lua*](https://github.com/openresty/lua-nginx-module#content_by_lua).
- `header_filter`for the context of [header_filter_by_lua*](https://github.com/openresty/lua-nginx-module#header_filter_by_lua).
- `body_filter`for the context of [body_filter_by_lua*](https://github.com/openresty/lua-nginx-module#body_filter_by_lua).
- `log`for the context of [log_by_lua*](https://github.com/openresty/lua-nginx-module#log_by_lua).
- `timer`for the context of user callback functions for [ngx.timer.*](https://github.com/openresty/lua-nginx-module#ngxtimerat).

This API was first introduced in the `v0.5.10` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.thread.spawn

**syntax:** *co = ngx.thread.spawn(func, arg1, arg2, ...)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Spawns a new user "light thread" with the Lua function `func` as well as those optional arguments `arg1`, `arg2`, and etc. Returns a Lua thread (or Lua coroutine) object represents this "light thread".

"Light threads" are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.

Before `ngx.thread.spawn` returns, the `func` will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the [Nginx API for Lua](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) (like [tcpsock:receive](https://github.com/openresty/lua-nginx-module#tcpsockreceive)).

After `ngx.thread.spawn` returns, the newly-created "light thread" will keep running asynchronously usually at various I/O events.

All the Lua code chunks running by [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua), [access_by_lua](https://github.com/openresty/lua-nginx-module#access_by_lua), and [content_by_lua](https://github.com/openresty/lua-nginx-module#content_by_lua) are in a boilerplate "light thread" created automatically by ngx_lua. Such boilerplate "light thread" are also called "entry threads".

By default, the corresponding Nginx handler (e.g., [rewrite_by_lua](https://github.com/openresty/lua-nginx-module#rewrite_by_lua) handler) will not terminate until

1. both the "entry thread" and all the user "light threads" terminates,
2. a "light thread" (either the "entry thread" or a user "light thread" aborts by calling [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit), [ngx.exec](https://github.com/openresty/lua-nginx-module#ngxexec), [ngx.redirect](https://github.com/openresty/lua-nginx-module#ngxredirect), or [ngx.req.set_uri(uri, true)](https://github.com/openresty/lua-nginx-module#ngxreqset_uri), or
3. the "entry thread" terminates with a Lua error.

When the user "light thread" terminates with a Lua error, however, it will not abort other running "light threads" like the "entry thread" does.

Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running "light thread" that is pending on one ore more Nginx subrequests. You must call [ngx.thread.wait](https://github.com/openresty/lua-nginx-module#ngxthreadwait) to wait for those "light thread" to terminate before quitting the "world". A notable exception here is that you can abort pending subrequests by calling [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit) with and only with the status code `ngx.ERROR` (-1), `408`, `444`, or `499`.

The "light threads" are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A "light thread" will keep running exclusively on the CPU until

1. a (nonblocking) I/O operation cannot be completed in a single run,
2. it calls [coroutine.yield](https://github.com/openresty/lua-nginx-module#coroutineyield) to actively give up execution, or
3. it is aborted by a Lua error or an invocation of [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit), [ngx.exec](https://github.com/openresty/lua-nginx-module#ngxexec), [ngx.redirect](https://github.com/openresty/lua-nginx-module#ngxredirect), or [ngx.req.set_uri(uri, true)](https://github.com/openresty/lua-nginx-module#ngxreqset_uri).

For the first two cases, the "light thread" will usually be resumed later by the ngx_lua scheduler unless a "stop-the-world" event happens.

User "light threads" can create "light threads" themselves. And normal user coroutines created by [coroutine.create](https://github.com/openresty/lua-nginx-module#coroutinecreate) can also create "light threads". The coroutine (be it a normal Lua coroutine or a "light thread") that directly spawns the "light thread" is called the "parent coroutine" for the "light thread" newly spawned.

The "parent coroutine" can call [ngx.thread.wait](https://github.com/openresty/lua-nginx-module#ngxthreadwait) to wait on the termination of its child "light thread".

You can call coroutine.status() and coroutine.yield() on the "light thread" coroutines.

The status of the "light thread" coroutine can be "zombie" if

1. the current "light thread" already terminates (either successfully or with an error),
2. its parent coroutine is still alive, and
3. its parent coroutine is not waiting on it with [ngx.thread.wait](https://github.com/openresty/lua-nginx-module#ngxthreadwait).

The following example demonstrates the use of coroutine.yield() in the "light thread" coroutinesto do manual time-slicing:

```
 local yield = coroutine.yield

 function f()
     local self = coroutine.running()
     ngx.say("f 1")
     yield(self)
     ngx.say("f 2")
     yield(self)
     ngx.say("f 3")
 end

 local self = coroutine.running()
 ngx.say("0")
 yield(self)

 ngx.say("1")
 ngx.thread.spawn(f)

 ngx.say("2")
 yield(self)

 ngx.say("3")
 yield(self)

 ngx.say("4")
```

Then it will generate the output

```
0
1
f 1
2
f 2
3
f 3
4

```

"Light threads" are mostly useful for making concurrent upstream requests in a single Nginx request handler, much like a generalized version of [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi) that can work with all the [Nginx API for Lua](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua). The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (similar to Facebook's BigPipe model):

```
 -- query mysql, memcached, and a remote http service at the same time,
 -- output the results in the order that they
 -- actually return the results.

 local mysql = require "resty.mysql"
 local memcached = require "resty.memcached"

 local function query_mysql()
     local db = mysql:new()
     db:connect{
                 host = "127.0.0.1",
                 port = 3306,
                 database = "test",
                 user = "monty",
                 password = "mypass"
               }
     local res, err, errno, sqlstate =
             db:query("select * from cats order by id asc")
     db:set_keepalive(0, 100)
     ngx.say("mysql done: ", cjson.encode(res))
 end

 local function query_memcached()
     local memc = memcached:new()
     memc:connect("127.0.0.1", 11211)
     local res, err = memc:get("some_key")
     ngx.say("memcached done: ", res)
 end

 local function query_http()
     local res = ngx.location.capture("/my-http-proxy")
     ngx.say("http done: ", res.body)
 end

 ngx.thread.spawn(query_mysql)      -- create thread 1
 ngx.thread.spawn(query_memcached)  -- create thread 2
 ngx.thread.spawn(query_http)       -- create thread 3
```

This API was first enabled in the `v0.7.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.thread.wait

**syntax:** *ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua**

Waits on one or more child "light threads" and returns the results of the first "light thread" that terminates (either successfully or with an error).

The arguments `thread1`, `thread2`, and etc are the Lua thread objects returned by earlier calls of [ngx.thread.spawn](https://github.com/openresty/lua-nginx-module#ngxthreadspawn).

The return values have exactly the same meaning as [coroutine.resume](https://github.com/openresty/lua-nginx-module#coroutineresume), that is, the first value returned is a boolean value indicating whether the "light thread" terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the "light thread" (in case of success) or the error object (in case of failure).

Only the direct "parent coroutine" can wait on its child "light thread", otherwise a Lua exception will be raised.

The following example demonstrates the use of `ngx.thread.wait` and [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) to emulate [ngx.location.capture_multi](https://github.com/openresty/lua-nginx-module#ngxlocationcapture_multi):

```
 local capture = ngx.location.capture
 local spawn = ngx.thread.spawn
 local wait = ngx.thread.wait
 local say = ngx.say

 local function fetch(uri)
     return capture(uri)
 end

 local threads = {
     spawn(fetch, "/foo"),
     spawn(fetch, "/bar"),
     spawn(fetch, "/baz")
 }

 for i = 1, #threads do
     local ok, res = wait(threads[i])
     if not ok then
         say(i, ": failed to run: ", res)
     else
         say(i, ": status: ", res.status)
         say(i, ": body: ", res.body)
     end
 end
```

Here it essentially implements the "wait all" model.

And below is an example demonstrating the "wait any" model:

```
 function f()
     ngx.sleep(0.2)
     ngx.say("f: hello")
     return "f done"
 end

 function g()
     ngx.sleep(0.1)
     ngx.say("g: hello")
     return "g done"
 end

 local tf, err = ngx.thread.spawn(f)
 if not tf then
     ngx.say("failed to spawn thread f: ", err)
     return
 end

 ngx.say("f thread created: ", coroutine.status(tf))

 local tg, err = ngx.thread.spawn(g)
 if not tg then
     ngx.say("failed to spawn thread g: ", err)
     return
 end

 ngx.say("g thread created: ", coroutine.status(tg))

 ok, res = ngx.thread.wait(tf, tg)
 if not ok then
     ngx.say("failed to wait: ", res)
     return
 end

 ngx.say("res: ", res)

 -- stop the "world", aborting other running threads
 ngx.exit(ngx.OK)
```

And it will generate the following output:

```
f thread created: running
g thread created: running
g: hello
res: g done

```

This API was first enabled in the `v0.7.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.thread.kill

**syntax:** *ok, err = ngx.thread.kill(thread)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, ngx.timer.**

Kills a running "light thread" created by [ngx.thread.spawn](https://github.com/openresty/lua-nginx-module#ngxthreadspawn). Returns a true value when successful or `nil` and a string describing the error otherwise.

According to the current implementation, only the parent coroutine (or "light thread") can kill a thread. Also, a running "light thread" with pending NGINX subrequests (initiated by [ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture) for example) cannot be killed due to a limitation in the NGINX core.

This API was first enabled in the `v0.9.9` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.on_abort

**syntax:** *ok, err = ngx.on_abort(callback)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua**

Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.

Returns `1` if the callback is registered successfully or returns `nil` and a string describing the error otherwise.

All the [Nginx API for Lua](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua) can be used in the callback function because the function is run in a special "light thread", just as those "light threads" created by [ngx.thread.spawn](https://github.com/openresty/lua-nginx-module#ngxthreadspawn).

The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit), for example,

```
 local function my_cleanup()
     -- custom cleanup work goes here, like cancelling a pending DB transaction

     -- now abort all the "light threads" running in the current request handler
     ngx.exit(499)
 end

 local ok, err = ngx.on_abort(my_cleanup)
 if not ok then
     ngx.log(ngx.ERR, "failed to register the on_abort callback: ", err)
     ngx.exit(500)
 end
```

When [lua_check_client_abort](https://github.com/openresty/lua-nginx-module#lua_check_client_abort) is set to `off` (which is the default), then this function call will always return the error message "lua_check_client_abort is off".

According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message "duplicate call".

This API was first introduced in the `v0.7.4` release.

See also [lua_check_client_abort](https://github.com/openresty/lua-nginx-module#lua_check_client_abort).

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.timer.at

**syntax:** *hdl, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Creates an Nginx timer with a user callback function as well as optional user arguments.

The first argument, `delay`, specifies the delay for the timer,in seconds. One can specify fractional seconds like `0.001` to mean 1millisecond here. `0` delay can also be specified, in which case thetimer will immediately expire when the current handler yieldsexecution.

The second argument, `callback`, canbe any Lua function, which will be invoked later in a background"light thread" after the delay specified. The user callback will becalled automatically by the Nginx core with the arguments `premature`,`user_arg1`, `user_arg2`, and etc, where the `premature`argument takes a boolean value indicating whether it is a premature timerexpiration or not, and `user_arg1`, `user_arg2`, and etc, arethose (extra) user arguments specified when calling `ngx.timer.at`as the remaining arguments.

Premature timer expiration happens when the Nginx worker process istrying to shut down, as in an Nginx configuration reload triggered bythe `HUP` signal or in an Nginx server shutdown. When the Nginx workeris trying to shut down, one can no longer call `ngx.timer.at` tocreate new timers with nonzero delays and in that case `ngx.timer.at` will return a "conditional false" value anda string describing the error, that is, "process exiting".

Starting from the `v0.9.3` release, it is allowed to create zero-delay timers even when the Nginx worker process starts shutting down.

When a timer expires, the user Lua code in the timer callback isrunning in a "light thread" detached completely from the originalrequest creating the timer. So objects with the same lifetime as therequest creating them, like [cosockets](https://github.com/openresty/lua-nginx-module#ngxsockettcp), cannot be shared between theoriginal request and the timer user callback function.

Here is a simple example:

```
 location / {
     ...
     log_by_lua_block {
         local function push_data(premature, uri, args, status)
             -- push the data uri, args, and status to the remote
             -- via ngx.socket.tcp or ngx.socket.udp
             -- (one may want to buffer the data in Lua a bit to
             -- save I/O operations)
         end
         local ok, err = ngx.timer.at(0, push_data,
                                      ngx.var.uri, ngx.var.args, ngx.header.status)
         if not ok then
             ngx.log(ngx.ERR, "failed to create timer: ", err)
             return
         end
     }
 }
```

One can also create infinite re-occurring timers, for instance, a timer getting triggered every `5` seconds, by calling `ngx.timer.at` recursively in the timer callback function. Here is such an example,

```
 local delay = 5
 local handler
 handler = function (premature)
     -- do some routine job in Lua just like a cron job
     if premature then
         return
     end
     local ok, err = ngx.timer.at(delay, handler)
     if not ok then
         ngx.log(ngx.ERR, "failed to create the timer: ", err)
         return
     end
 end

 local ok, err = ngx.timer.at(delay, handler)
 if not ok then
     ngx.log(ngx.ERR, "failed to create the timer: ", err)
     return
 end
```

It is recommended, however, to use the [ngx.timer.every](https://github.com/openresty/lua-nginx-module#ngxtimerevery) API functioninstead for creating recurring timers since it is more robust.

Because timer callbacks run in the background and their running timewill not add to any client request's response time, they can easilyaccumulate in the server and exhaust system resources due to eitherLua programming mistakes or just too much client traffic. To preventextreme consequences like crashing the Nginx server, there arebuilt-in limitations on both the number of "pending timers" and thenumber of "running timers" in an Nginx worker process. The "pendingtimers" here mean timers that have not yet been expired and "runningtimers" are those whose user callbacks are currently running.

The maximal number of pending timers allowed in an Nginxworker is constrolled by the [lua_max_pending_timers](https://github.com/openresty/lua-nginx-module#lua_max_pending_timers)directive. The maximal number of running timers is controlled by the[lua_max_running_timers](https://github.com/openresty/lua-nginx-module#lua_max_running_timers) directive.

According to the current implementation, each "running timer" willtake one (fake) connection record from the global connection recordlist configured by the standard [worker_connections](http://nginx.org/en/docs/ngx_core_module.html#worker_connections) directive in`nginx.conf`. So ensure that the[worker_connections](http://nginx.org/en/docs/ngx_core_module.html#worker_connections) directive is set toa large enough value that takes into account both the real connectionsand fake connections required by timer callbacks (as limited by the[lua_max_running_timers](https://github.com/openresty/lua-nginx-module#lua_max_running_timers) directive).

A lot of the Lua APIs for Nginx are enabled in the context of the timercallbacks, like stream/datagram cosockets ([ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp) and [ngx.socket.udp](https://github.com/openresty/lua-nginx-module#ngxsocketudp)), sharedmemory dictionaries ([ngx.shared.DICT](https://github.com/openresty/lua-nginx-module#ngxshareddict)), user coroutines ([coroutine.*](https://github.com/openresty/lua-nginx-module#coroutinecreate)),user "light threads" ([ngx.thread.*](https://github.com/openresty/lua-nginx-module#ngxthreadspawn)), [ngx.exit](https://github.com/openresty/lua-nginx-module#ngxexit), [ngx.now](https://github.com/openresty/lua-nginx-module#ngxnow)/[ngx.time](https://github.com/openresty/lua-nginx-module#ngxtime),[ngx.md5](https://github.com/openresty/lua-nginx-module#ngxmd5)/[ngx.sha1_bin](https://github.com/openresty/lua-nginx-module#ngxsha1_bin), are all allowed. But the subrequest API (like[ngx.location.capture](https://github.com/openresty/lua-nginx-module#ngxlocationcapture)), the [ngx.req.*](https://github.com/openresty/lua-nginx-module#ngxreqstart_time) API, the downstream output API(like [ngx.say](https://github.com/openresty/lua-nginx-module#ngxsay), [ngx.print](https://github.com/openresty/lua-nginx-module#ngxprint), and [ngx.flush](https://github.com/openresty/lua-nginx-module#ngxflush)) are explicitly disabled inthis context.

You can pass most of the standard Lua values (nils, booleans, numbers, strings, tables, closures, file handles, and etc) into the timer callback, either explicitly as user arguments or implicitly as upvalues for the callback closure. There are several exceptions, however: you *cannot* pass any thread objects returned by [coroutine.create](https://github.com/openresty/lua-nginx-module#coroutinecreate) and [ngx.thread.spawn](https://github.com/openresty/lua-nginx-module#ngxthreadspawn) or any cosocket objects returned by [ngx.socket.tcp](https://github.com/openresty/lua-nginx-module#ngxsockettcp), [ngx.socket.udp](https://github.com/openresty/lua-nginx-module#ngxsocketudp), and [ngx.req.socket](https://github.com/openresty/lua-nginx-module#ngxreqsocket) because these objects' lifetime is bound to the request context creating them while the timer callback is detached from the creating request's context (by design) and runs in its own (fake) request context. If you try to share the thread or cosocket objects across the boundary of the creating request, then you will get the "no co ctx found" error (for threads) or "bad request" (for cosockets). It is fine, however, to create all these objects inside your timer callback.

This API was first introduced in the `v0.8.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.timer.every

**syntax:** *hdl, err = ngx.timer.every(delay, callback, user_arg1, user_arg2, ...)*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to the [ngx.timer.at](https://github.com/openresty/lua-nginx-module#ngxtimerat) API function, but

1. `delay` *cannot* be zero,
2. timer will be created every `delay` seconds until the current Nginx worker process starts exiting.

When success, returns a "conditional true" value (but not a `true`). Otherwise, returns a "conditional false" value and a string describing the error.

This API also respect the [lua_max_pending_timers](https://github.com/openresty/lua-nginx-module#lua_max_pending_timers) and [lua_max_running_timers](https://github.com/openresty/lua-nginx-module#lua_max_running_timers).

This API was first introduced in the `v0.10.9` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.timer.running_count

**syntax:** *count = ngx.timer.running_count()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the number of timers currently running.

This directive was first introduced in the `v0.9.20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.timer.pending_count

**syntax:** *count = ngx.timer.pending_count()*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Returns the number of pending timers.

This directive was first introduced in the `v0.9.20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.config.subsystem

**syntax:** *subsystem = ngx.config.subsystem*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua**

This string field indicates the current NGINX subsystem the current Lua environment is based on. For this module, this field always takes the string value `"http"`. For[ngx_stream_lua_module](https://github.com/openresty/stream-lua-nginx-module#readme), however, this field takes the value `"stream"`.

This field was first introduced in the `0.10.1`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.config.debug

**syntax:** *debug = ngx.config.debug*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua**

This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the `./configure` option `--with-debug`.

This field was first introduced in the `0.8.7`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.config.prefix

**syntax:** *prefix = ngx.config.prefix()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua**

Returns the Nginx server "prefix" path, as determined by the `-p` command-line option when running the nginx executable, or the path specified by the `--prefix` command-line option when building Nginx with the `./configure` script.

This function was first introduced in the `0.9.2`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.config.nginx_version

**syntax:** *ver = ngx.config.nginx_version*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua**

This field take an integral value indicating the version number of the current Nginx core being used. For example, the version number `1.4.3` results in the Lua number 1004003.

This API was first introduced in the `0.9.3` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.config.nginx_configure

**syntax:** *str = ngx.config.nginx_configure()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua**

This function returns a string for the NGINX `./configure` command's arguments string.

This API was first introduced in the `0.9.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.config.ngx_lua_version

**syntax:** *ver = ngx.config.ngx_lua_version*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua**

This field take an integral value indicating the version number of the current `ngx_lua` module being used. For example, the version number `0.9.3` results in the Lua number 9003.

This API was first introduced in the `0.9.3` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.worker.exiting

**syntax:** *exiting = ngx.worker.exiting()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua**

This function returns a boolean value indicating whether the current Nginx worker process already starts exiting. Nginx worker process exiting happens on Nginx server quit or configuration reload (aka HUP reload).

This API was first introduced in the `0.9.3` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.worker.pid

**syntax:** *pid = ngx.worker.pid()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua**

This function returns a Lua number for the process ID (PID) of the current Nginx worker process. This API is more efficient than `ngx.var.pid` and can be used in contexts where the [ngx.var.VARIABLE](https://github.com/openresty/lua-nginx-module#ngxvarvariable) API cannot be used (like [init_worker_by_lua](https://github.com/openresty/lua-nginx-module#init_worker_by_lua)).

This API was first introduced in the `0.9.5` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.worker.count

**syntax:** *count = ngx.worker.count()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua**

Returns the total number of the Nginx worker processes (i.e., the value configuredby the [worker_processes](http://nginx.org/en/docs/ngx_core_module.html#worker_processes)directive in `nginx.conf`).

This API was first introduced in the `0.9.20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.worker.id

**syntax:** *count = ngx.worker.id()*

**context:** *set_by_lua\*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_worker_by_lua**

Returns the ordinal number of the current Nginx worker processes (starting from number 0).

So if the total number of workers is `N`, then this method may return a number between 0and `N - 1` (inclusive).

This function returns meaningful values only for NGINX 1.9.1+. With earlier versions of NGINX, italways returns `nil`.

See also [ngx.worker.count](https://github.com/openresty/lua-nginx-module#ngxworkercount).

This API was first introduced in the `0.9.20` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.semaphore

**syntax:** *local semaphore = require "ngx.semaphore"*

This is a Lua module that implements a classic-style semaphore API for efficient synchronizations amongdifferent "light threads". Sharing the same semaphore among different "light threads" created in different (request)contexts are also supported as long as the "light threads" reside in the same NGINX worker processand the [lua_code_cache](https://github.com/openresty/lua-nginx-module#lua_code_cache) directive is turned on (which is the default).

This Lua module does not ship with this ngx_lua module itself rather it is shipped withthe[lua-resty-core](https://github.com/openresty/lua-resty-core) library.

Please refer to the [documentation](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/semaphore.md)for this `ngx.semaphore` Lua module in [lua-resty-core](https://github.com/openresty/lua-resty-core)for more details.

This feature requires at least ngx_lua `v0.10.0`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.balancer

**syntax:** *local balancer = require "ngx.balancer"*

This is a Lua module that provides a Lua API to allow defining completely dynamic load balancersin pure Lua.

This Lua module does not ship with this ngx_lua module itself rather it is shipped withthe[lua-resty-core](https://github.com/openresty/lua-resty-core) library.

Please refer to the [documentation](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md)for this `ngx.balancer` Lua module in [lua-resty-core](https://github.com/openresty/lua-resty-core)for more details.

This feature requires at least ngx_lua `v0.10.0`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.ssl

**syntax:** *local ssl = require "ngx.ssl"*

This Lua module provides API functions to control the SSL handshake process in contexts like[ssl_certificate_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block).

This Lua module does not ship with this ngx_lua module itself rather it is shipped withthe[lua-resty-core](https://github.com/openresty/lua-resty-core) library.

Please refer to the [documentation](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md)for this `ngx.ssl` Lua module for more details.

This feature requires at least ngx_lua `v0.10.0`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ngx.ocsp

**syntax:** *local ocsp = require "ngx.ocsp"*

This Lua module provides API to perform OCSP queries, OCSP response validations, andOCSP stapling planting.

Usually, this module is used together with the [ngx.ssl](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md)module in thecontext of [ssl_certificate_by_lua*](https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block).

This Lua module does not ship with this ngx_lua module itself rather it is shipped withthe[lua-resty-core](https://github.com/openresty/lua-resty-core) library.

Please refer to the [documentation](https://github.com/openresty/lua-resty-core/blob/ocsp-cert-by-lua-2/lib/ngx/ocsp.md)for this `ngx.ocsp` Lua module for more details.

This feature requires at least ngx_lua `v0.10.0`.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## ndk.set_var.DIRECTIVE

**syntax:** *res = ndk.set_var.DIRECTIVE_NAME*

**context:** *init_worker_by_lua\*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

This mechanism allows calling other nginx C modules' directives that are implemented by [Nginx Devel Kit](https://github.com/simpl/ngx_devel_kit) (NDK)'s set_var submodule's `ndk_set_var_value`.

For example, the following [set-misc-nginx-module](http://github.com/openresty/set-misc-nginx-module) directives can be invoked this way:

- [set_quote_sql_str](http://github.com/openresty/set-misc-nginx-module#set_quote_sql_str)
- [set_quote_pgsql_str](http://github.com/openresty/set-misc-nginx-module#set_quote_pgsql_str)
- [set_quote_json_str](http://github.com/openresty/set-misc-nginx-module#set_quote_json_str)
- [set_unescape_uri](http://github.com/openresty/set-misc-nginx-module#set_unescape_uri)
- [set_escape_uri](http://github.com/openresty/set-misc-nginx-module#set_escape_uri)
- [set_encode_base32](http://github.com/openresty/set-misc-nginx-module#set_encode_base32)
- [set_decode_base32](http://github.com/openresty/set-misc-nginx-module#set_decode_base32)
- [set_encode_base64](http://github.com/openresty/set-misc-nginx-module#set_encode_base64)
- [set_decode_base64](http://github.com/openresty/set-misc-nginx-module#set_decode_base64)
- [set_encode_hex](http://github.com/openresty/set-misc-nginx-module#set_encode_base64)
- [set_decode_hex](http://github.com/openresty/set-misc-nginx-module#set_decode_base64)
- [set_sha1](http://github.com/openresty/set-misc-nginx-module#set_encode_base64)
- [set_md5](http://github.com/openresty/set-misc-nginx-module#set_decode_base64)

For instance,

```
 local res = ndk.set_var.set_escape_uri('a/b');
 -- now res == 'a%2fb'
```

Similarly, the following directives provided by [encrypted-session-nginx-module](http://github.com/openresty/encrypted-session-nginx-module) can be invoked from within Lua too:

- [set_encrypt_session](http://github.com/openresty/encrypted-session-nginx-module#set_encrypt_session)
- [set_decrypt_session](http://github.com/openresty/encrypted-session-nginx-module#set_decrypt_session)

This feature requires the [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) module.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## coroutine.create

**syntax:** *co = coroutine.create(f)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Creates a user Lua coroutines with a Lua function, and returns a coroutine object.

Similar to the standard Lua [coroutine.create](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create) API, but works in the context of the Lua coroutines created by ngx_lua.

This API was first usable in the context of [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua) since the `0.9.2`.

This API was first introduced in the `v0.6.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## coroutine.resume

**syntax:** *ok, ... = coroutine.resume(co, ...)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Resumes the executation of a user Lua coroutine object previously yielded or just created.

Similar to the standard Lua [coroutine.resume](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume) API, but works in the context of the Lua coroutines created by ngx_lua.

This API was first usable in the context of [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua) since the `0.9.2`.

This API was first introduced in the `v0.6.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## coroutine.yield

**syntax:** *... = coroutine.yield(...)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Yields the execution of the current user Lua coroutine.

Similar to the standard Lua [coroutine.yield](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield) API, but works in the context of the Lua coroutines created by ngx_lua.

This API was first usable in the context of [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua) since the `0.9.2`.

This API was first introduced in the `v0.6.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## coroutine.wrap

**syntax:** *co = coroutine.wrap(f)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Similar to the standard Lua [coroutine.wrap](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap) API, but works in the context of the Lua coroutines created by ngx_lua.

This API was first usable in the context of [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua) since the `0.9.2`.

This API was first introduced in the `v0.6.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## coroutine.running

**syntax:** *co = coroutine.running()*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Identical to the standard Lua [coroutine.running](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running) API.

This API was first usable in the context of [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua) since the `0.9.2`.

This API was first enabled in the `v0.6.0` release.

[Back to TOC](https://github.com/openresty/lua-nginx-module#nginx-api-for-lua)

## coroutine.status

**syntax:** *status = coroutine.status(co)*

**context:** *rewrite_by_lua\*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua**

Identical to the standard Lua [coroutine.status](http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status) API.

This API was first usable in the context of [init_by_lua*](https://github.com/openresty/lua-nginx-module#init_by_lua) since the `0.9.2`.

This API was first enabled in the `v0.6.0` release.
